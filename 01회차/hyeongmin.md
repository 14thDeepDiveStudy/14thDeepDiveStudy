## 비동기 프로그래밍

### 동기 처리와 비동기 처리

자바스크립트 엔진은 **하나의 실행 컨텍스트 스택(콜 스택)**을 가짐. 이건 즉, 한 번에 하나의 작업만 처리할 수 있는 싱글 스레드 방식이라는 의미임. 함수가 호출되면 순서대로 콜 스택에 쌓이고, 가장 위에 있는 함수부터 실행된 후 스택에서 제거됨. 이런 방식을 동기(Synchronous) 처리라고 함.

동기 방식은 순서가 보장된다는 장점이 있지만, 하나의 작업이 오래 걸리면 그 뒤의 작업들은 모두 기다려야 하는 블로킹(blocking) 현상이 발생함.
(책의 sleep 함수 예제)

반면 비동기(Asynchronous) 처리는 현재 실행 중인 작업이 끝나지 않아도 다음 작업을 바로 시작하는 방식임.
(책의 foo함수 예제)
setTimeout 함수가 대표적인 예시임. setTimeout(foo, 3000)을 실행하면, 3초를 기다렸다가 foo 함수를 실행하는 게 아니라, 일단 타이머를 설정해두고 바로 다음 코드(bar())를 실행함. 덕분에 블로킹이 발생하지 않음. 하지만 작업 순서가 보장되지 않는 단점이 있음.

> 생각해볼 점:
> 비동기 처리는 순서가 보장되지 않아서 콜백 함수를 사용하는데, 이게 깊어지면 '콜백 헬'이 발생한다고 함. 에러 처리도 복잡해진다고 함. 이걸 해결하기 위해 나온 Promise나 async/await가 필요하다고 하는데, 이는 8월 4일의 주제이기도 함. 일단 해결에 대한 부분은 다음주의 기쁨으로 놓고, 어떤 문제가 생기는지를 명확히 알기 위해 해당 내용을 읽어보았음.

> 어떤 문제가 생기나?
>
> 1.  콜백 헬 (Callback Hell) 문제: 비동기 작업을 순서대로 처리해야 할 때, 콜백 함수 안에 또 다른 콜백 함수를 계속 중첩시키는 구조가 만들어짐. 코드가 끝없이 오른쪽으로 파고드는 형태가 되어 가독성이 심각하게 떨어지고 로직 파악이 매우 어려워진다.
>
> 2.  에러 처리의 한계: 이게 더 결정적인 문제라고 하는데, try...catch 문으로는 비동기 콜백 함수 내부에서 발생하는 에러를 잡을 수 없음. 에러가 발생하는 시점과 try...catch가 실행되는 시점이 다르기 때문. 결국, 각각의 비동기 작업마다 개별적으로 에러를 처리해야 해서 코드가 복잡해지고 에러 처리가 파편화됨.

가독성과 에러처리 양쪽 측면에서 문제가 생기는 듯 한데 요약했듯이 에러 처리에 무게를 두는 느낌임.

### 이벤트 루프와 태스크 큐

자바스크립트 엔진은 싱글 스레드인데(6월달 강의분 기준으로 2주 차 때 야무쌤께서 수업시간에 언급해주신 부분) 어떻게 비동기 작업이 가능한지 궁금했는데, 그 비밀은 브라우저 환경에 있었음. 자바스크립트 엔진 자체는 콜 스택과 힙(메모리 할당 영역)으로만 구성되어 요청된 작업을 순차적으로 실행할 뿐이고, 비동기 작업의 핵심은 브라우저(또는 Node.js)가 제공하는 Web API, 태스크 큐(Task Queue), 그리고 **이벤트 루프(Event Loop)**에 있음. 아래와 같은 흐름.

> setTimeout 같은 비동기 함수가 호출되면, 자바스크립트 엔진은 이를 Web API에 위임함.
>
> Web API는 타이머를 설정하고, 시간이 만료되면 콜백 함수를 태스크 큐라는 대기 공간으로 보냄.
>
> 이벤트 루프는 콜 스택이 비어있는지 계속 확인하다가, 비는 순간 태스크 큐에서 가장 오래된 작업을 꺼내 콜 스택으로 옮겨 실행시킴.

결국, 자바스크립트 엔진은 싱글 스레드로 동작하지만, **브라우저는 멀티 스레드로 동작하면서 이런 비동기 작업들을 백그라운드에서 처리**하고, 그 결과를 태스크 큐에 넣어주는 협업 구조였음.

> 알게 된 점과 의문:
> setTimeout(callback, 0)으로 설정해도 바로 실행되지 않고 bar() 함수가 먼저 실행되는 이유를 알겠음. 지연 시간이 0이어도 3ms의 기본 시간이 있기 때문에, 일단 태스크 큐로 들어갔다가, 콜 스택에 있는 모든 동기 코드가 실행되고 나서야 이벤트 루프에 의해 콜 스택으로 옮겨지기 때문! 한편 여기서 '마이크로태스크 큐'라는 것도 있다고 하는데, 일반 태스크 큐와는 우선순위가 다른 것 같음. Promise의 후속 처리 메서드는 마이크로태스크 큐로 들어간다고 하니, 둘의 정확한 동작 차이에 집중해서 뒷 내용을 읽어봐야할 것.

## Ajax

### Ajax

\*\*Ajax(Asynchronous JavaScript and XML)&&는 웹페이지 전체를 새로고침하지 않고, 서버와 비동기 통신을 통해 데이터의 일부만 받아와 동적으로 화면을 갱신하는 기술인데, 요즘 웹의 부드러운 사용자 경험은 대부분 Ajax 덕분임.

이때 서버와 데이터를 주고받는 표준 포맷으로 **JSON(JavaScript Object Notation)**을 주로 사용함. JSON은 자바스크립트 객체 리터럴과 비슷하게 생겼지만 **순수한 텍스트**임.

    의문과 해결:
    순수한 텍스트?!! 라는 것이 무엇인고 하니.. 객체의 내용을 그대로 베껴 쓴 '문자열(string)'이라는 뜻으로 컴퓨터들끼리 데이터를 잘 주고받을 수 있도록, 텍스트들을 설계도로써 전달하는 것.

### JSON (JavaScript Object Notation)

JSON은 클라이언트와 서버 간 HTTP 통신을 위한 텍스트 데이터 포맷임. 자바스크립트 객체 리터럴과 비슷하게 키:값 쌍으로 이루어져 있지만, 언어에 종속되지 않아(앞서 설명했듯이 순수 텍스트 이므로) 대부분의 프로그래밍 언어에서 사용할 수 있음.

JSON 표기 방식의 핵심 규칙:

- 키는 **반드시 큰따옴표("")**로 감싸야 함.
- 문자열 값도 **반드시 큰따옴표("")**로 감싸야 함. (작은따옴표 사용 불가)

주요 메소드로는 두 가지가 있음.

- JSON.stringify(): 자바스크립트 객체를 JSON 포맷의 문자열로 변환함 (직렬화, Serialization). 서버로 객체를 전송할 때 사용함.
- JSON.parse(): JSON 포맷의 문자열을 자바스크립트 객체로 변환함 (역직렬화, Deserialization). 서버로부터 받은 데이터를 자바스크립트에서 사용하기 위해 필요함.

### XMLHttpRequest (XHR)

자바스크립트를 사용해 HTTP 요청을 보내려면 XMLHttpRequest 객체를 사용해야 함. 이 객체는 HTTP 요청과 응답을 다루기 위한 다양한 프로퍼티와 메소드를 제공함.

HTTP 요청 전송 과정:

    - new XMLHttpRequest()로 객체를 생성함.

    - xhr.open(method, url) 메소드로 요청을 초기화함. (예: open('GET', '/users'))

    - 필요하다면 xhr.setRequestHeader(header, value)로 요청 헤더를 설정함.

        - Content-Type: 보내는 데이터의 MIME 타입 (예: application/json)

        - Accept: 받고자 하는 데이터의 MIME 타입

    - xhr.send(payload) 메소드로 요청을 전송함. POST 요청의 경우, send 메소드의 인자로 데이터를 전달함. (이때 객체는 JSON.stringify로 문자열화해야 함)

HTTP 응답 처리:
서버 응답은 비동기적으로 오기 때문에 이벤트 핸들러를 통해 처리해야 함.

    - onreadystatechange: 요청 상태(readyState)가 변할 때마다 호출됨.

        - xhr.readyState가 XMLHttpRequest.DONE (값: 4)인지 확인하여 응답 완료 여부를 체크함.

        - xhr.status가 200인지 확인하여 요청 성공 여부를 체크함.

        - 성공 시 xhr.response나 xhr.responseText로 응답 데이터를 받음.

    - onload: 요청이 성공적으로 완료되었을 때만 호출됨. readyState를 체크할 필요가 없어 코드가 더 간결해짐.

생각해볼 점: readyState가 UNSENT(0)부터 DONE(4)까지 여러 단계로 나뉘어 있는데, 실제 코딩할 때 DONE(4) 상태 외에 HEADERS_RECEIVED(2)나 LOADING(3) 같은 중간 상태를 체크해서 특별한 처리를 하는 경우가 많을까? 아니면 보통 onload 이벤트 핸들러로 완료 시점만 체크하는 게 일반적일까? 파일 업로드 진행률 표시 같은 기능에 활용 여부??

## REST API 설계 원칙 및 실습 요약

### REST API 설계 원칙

REST API를 설계하는 데에는 두 가지 중요한 핵심 원칙이 있음.

- **첫째, URI는 리소스를 표현하는 데 집중해야 함.**
  URI는 '자원'을 나타내는 것이므로, 동사가 아닌 **명사**를 사용해 리소스를 식별해야 함. URI에 `get`, `delete` 같은 행위에 대한 표현이 들어가면 안 됨.

  - (Bad) `/getTodos/1`
  - (Good) `/todos/1`

- **둘째, 리소스에 대한 행위는 HTTP 요청 메서드로 표현해야 함.**
  리소스에 대한 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 등의 행위는 **HTTP 메서드**(POST, GET, PUT, PATCH, DELETE 등)를 사용해서 표현함.
  - (Bad) `GET /todos/delete/1`
  - (Good) `DELETE /todos/1`

#### **2. JSON Server를 이용한 REST API 실습**

`JSON Server`라는 툴을 이용해 가상 REST API 서버를 구축하고, 각 메서드를 호출하는 실습 내용.

- **JSON Server란?**

  - `json` 파일을 가상의 데이터베이스로 사용하여, 별다른 코드 없이 간단하게 REST API 서버를 구축하게 해주는 툴임.

- **실습 과정**

  1.  **설치:** `npm install json-server --save-dev` 명령어로 패키지를 설치함.
  2.  **DB 생성:** `db.json` 파일을 생성하고, 이 안에 `todos`와 같은 키와 객체 배열을 넣어 데이터베이스 역할을 하도록 만듦.
  3.  **서버 실행:** `json-server --watch db.json` 명령어로 서버를 실행함. `--watch` 옵션은 `db.json` 파일의 변경을 실시간으로 감지해서 서버에 반영해주는 역할을 함.
  4.  **스크립트 등록:** 매번 긴 명령어를 입력하기 번거로우니, `package.json`의 `scripts`에 `"start": "json-server --watch db.json"`과 같이 등록하여 `npm start` 명령어로 쉽게 서버를 실행할 수 있도록 했음.

- **메서드별 API 요청 실습**
  - 실습은 `XMLHttpRequest` 객체를 사용하여 각 HTTP 메서드를 호출하는 HTML 파일을 만들어 진행하는 식.
  - **`GET`:** 모든 리소스(`GET /todos`) 또는 특정 id의 리소스(`GET /todos/1`)를 조회함.
  - **`POST`:** 새로운 리소스를 생성(`POST /todos`). `setRequestHeader`로 페이로드의 MIME 타입을 `application/json`으로 지정하고, `send()` 메서드에 `JSON.stringify`로 변환된 객체를 담아 전송함.
  - **`PUT`:** 특정 리소스 전체를 교체(`PUT /todos/4`). `id`를 제외한 모든 데이터를 보내 리소스를 통째로 변경함.
  - **`PATCH`:** 특정 리소스의 일부를 수정(`PATCH /todos/4`). `completed` 값만 변경하는 것처럼, 리소스의 특정 필드만 수정함.
  - **`DELETE`:** 특정 리소스를 삭제(`DELETE /todos/4`).

> **생각**
>
> 실습 코드는 주제가 주제이니만큼... `XMLHttpRequest`를 기반으로 작성되어 있음. 요즘에는 **`fetch` API**나 **`axios`** 같은 라이브러리를 더 많이 사용하는 추세로 알고 있는데, `XMLHttpRequest`의 동작 원리를 상세히 이해하는 것이 기본기를 다지는 데는 도움이 될 것 같다는 생각은 듦. 한편 다음주의 주제로 하게 예정 되어있는 **Promise** 기반의 `fetch`가 비동기 코드를 더 간결하게 만들어주나, 최소한 작성을 편리하게 해주지 않을까 하는 생각이 듦.

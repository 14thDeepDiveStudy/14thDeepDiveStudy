# 🌟 1주차 - 비동기 프로그래밍/AJAX/Rest API

## 1. 비동기 프로그래밍

### 동기/비동기란?

- **동기(Synchronous)**
    
    요청과 결과가 동시에 일어난다는 뜻이다.
    즉, 작업대에서 한 번 작업을 시작하면 무조건 그 자리에서 결과를 완성해야 한다.
    
- **비동기(Asynchronous)**
    
    요청과 결과가 동시에 일어나지 않는다는 뜻.
    작업 시작 후 다른 곳에 들렀다 와서 결과를 받을 수 있다.
    

자바스크립트는 작업대가 하나밖에 없는 싱글 스레드 엔진을 사용한다. 
때문에 여러 코드를 병렬적으로 처리하지 못하고 동기적으로만 실행할 수 있다.
하지만 모던 웹같은 경우 동시에 처리해야 하는 작업이 매우매우 많음. (챗봇 동작시키면서 이미지 로딩하기 등등..)

그래서 브라우저와 Node.js같은 자바스크립트 실행 환경은 자체적으로 비동기 처리를 지원한다.
비동기 처리에 필요한 함수 스케쥴러와 여분의 작업 저장 공간을 제공해 준다는 것.
(자바스크립트 엔진 자체는 비동기 동작을 지원하지 않는다는 점에 유의하자)

![image](https://media.discordapp.net/attachments/1311319579913490442/1399344880030842960/image.png?ex=6888a8f9&is=68875779&hm=5d5ce9acbdc1b0b4c08b05b9905346e748c58193931b19f832894b8be9348ad0&=&format=webp&quality=lossless)

위 그림으로 비유하자면

카운터 = 작업대

진동벨 = 스케쥴러

가 된다.

### 이벤트 루프와 태스크 큐

자바스크립트 엔진이 코드를 동작시키는 원리를 알아보자.

일단 함수가 실행되면 해당 함수의 전용 **실행 컨텍스트(Execution Context)**가 생성된다.
실행 컨텍스트는 말 그대로 함수가 ‘실행’되기 위한 모든 ‘정보’를 담고 있는 ‘배경’이다. 실행 컨텍스트엔 아래와 같은 데이터들이 들어 있다.

- 변수 환경(함수 선언, 매개변수, `var` 변수 등)
    
    → 실행 시점에서 초기화와 바인딩이 한 번에 일어나는 값들
    
- **렉시컬 환경**(함수 스코프 정보, `let` / `const` 정보)
    
    → 실행 시점에서 초기화만 되고 선언문을 만났을 때 바인딩이 일어나는 값들(TDZ)
    
- `this` 바인딩 정보
    
    → 이 함수의 `this` 가 어떤 객체를 가리키는지? 전역에 실행된 함수의 경우 자동으로 `window` 객체가 바인딩된다. 하지만 `strict` 모드라면 바인딩이 일어나지 않아 `undefined` 가 됨.
    

**실행 컨텍스트 스택(=콜 스택 Call Stack)**은 이러한 실행 컨텍스트들을 차곡차곡 쌓아놓을 수 있는 자료구조이다. (자료구조=데이터 값의 모임)

자바스크립트 엔진은 작업대가 하나뿐인 싱글 스레드 언어라고 앞서 설명한 바 있는데,
이러한 특징 때문에 카페에서 줄을 서는 것처럼 함수들의 실행 순서를 관리해 줄 필요가 있다. 이 역할을 바로 **콜 스택**이 하는 것.
인터프리터가 함수 호출 구문을 만나면 즉시 콜 스택에 해당 함수의 실행 컨텍스트가 들어온다(push). 그리고 결과값이 반환되면 스택에서 빠진다(pop).

비동기 처리를 위해 브라우저가 자체적으로 지원하는 작업 대기 공간은 **태스크 큐(Task Queue=Callback Queue)**라고 부른다.
이 곳에는 스케쥴링 함수인 `setTimeout` , `addEventListener` 등에 넘겨지는 콜백 함수들이 저장된다. 
(스케쥴링 함수는 Web API에 콜백 함수 실행을 위임 후 바로 콜 스택에서 빠진다)

![image](https://media.discordapp.net/attachments/1311319579913490442/1399344880353935521/image_1.png?ex=6888a8fa&is=6887577a&hm=5bf22f750d0a176e7d77a0265e7b19f99f81ee04cc33955db4a12e136d5b3d42&=&format=webp&quality=lossless)

자바스크립트 엔진이 기본적으로 가지고 있는 콜 스택과 힙(동적 참조 데이터 저장 공간),
그리고 브라우저에서 지원하는 태스크 큐와 마이크로태스크 큐(프라미스 단원에서 설명)
이 공간들이 서로 순환하듯 태스크를 주고받으면서
비로소 태스트가 존재하는 동안엔 끊임없이 돌아가는 **이벤트 루프(Event Loop)**를 형성하게 된다.

### 스택?큐? 자료구조 기초 상식

**자료구조** = 쉽게 말해서 데이터 저장 공간.
데이터는 각각 어울리는 저장 방법이 있기 때문에 자료구조의 종류는 아주 많음.
많고많은 자료구조 중 이벤트 루프에서 볼 수 있었던 ‘스택’과 ‘큐’의 특징을 소개해 보겠다.

1. **스택(Stack)**
    
    ![image](https://media.discordapp.net/attachments/1311319579913490442/1399344880647667865/image_2.png?ex=6888a8fa&is=6887577a&hm=18a7da675007ccf034e493e979938094b5b4018eb64b46a31371253b01d705b3&=&format=webp&quality=lossless&width=854&height=738)
    
    **후입선출(LIFO, Last In First Out)** 구조로 이루어져 있는 데이터 저장 공간.
    자료의 삽입과 제거가 모두 한 곳(top)에서만 이루어진다.
    이처럼 자료구조의 맨 뒤에 데이터를 삽입하는 것을 **푸시(push)**, 맨 뒤에서 데이터를 꺼내 오는 것을 **팝(pop)**이라고 한다.
    먼저 실행된 함수는 먼저 결과를 얻는다. **즉 먼저 대기열에서 빠져야 한다.** 콜 스택이 스택 구조를 사용하는 이유는 이런 이유 때문.
    
2. **큐(Queue)**
    
    ![image](https://media.discordapp.net/attachments/1311319579913490442/1399344881285075085/image_3.png?ex=6888a8fa&is=6887577a&hm=fa788ecdff55139e89ce66977be3b050740cea6679179beb0fcc86e230d2e90a&=&format=webp&quality=lossless&width=1192&height=382)
    
    **선입선출(FIFO, First In First Out)** 구조로 이루어져 있는 데이터 저장 공간.
    자료의 삽입은 끝(back), 제거는 앞(front)에서만 일어난다.
    자료구조의 맨 앞에 데이터를 삽입하는 것을 **언쉬프트(unshift)**, 맨 앞에서 데이터를 꺼내는 것을 **쉬프트(shift)**라고 한다.
    **먼저 대기열에 등록된 콜백은 먼저 실행돼야 하기 때문**에 태스크 큐는 큐 구조를 쓴다.
    

## 2. AJAX

### AJAX란

웹 페이지 전체를 다시 로드하지 않고도 서버와 통신해서 일부 필요한 데이터만 갱신할 수 있게 해주는 기술.
서버와 비동기적으로 통신하여 백그라운드에서 데이터를 주고받을 수 있게 한다.
이 처리를 위해 자바스크립트와 브라우저에서는 `XMLHttpRequest` , `fetch` 와 같은 API를 지원한다.

책에 나와있듯 AJAX의 등장은 전통적인 서버 통신 방식을 획기적으로 바꾸었다.
과거에는 서버에서 클라이언트에게 웹페이지 전체 데이터를 전달하는 **서버 사이드 렌더링(Server Side Rendering)** 방식을 사용하였다.
페이지를 요청할 때마다 서버에서 html을 처음부터 끝까지 만들어 놓고 보내주는 방식.
하지만 이 방식은 웹이 발전하고 UX적인 기대치가 점점 높아지면서 SSR의 단점을 보완하기 위해 AJAX 방법론과 이를 지원하는 API가 등장하게 되었다.
AJAX 등장 이후부턴 스크립트를 이용해서 페이지의 필요한 부분만 동적으로 변화시키는 **클라이언트 사이드 렌더링(Client Side Rendering)** 방식이 널리 사용된다.

### Server Side Rendering VS Client Side Rendering

|  | SSR | CSR |
| --- | --- | --- |
| 장점 | - SEO 유리
- 첫 로딩속도 빠름 | - 페이지 전환 빠름
- 동적 UI 구현이 쉬움
- 재사용성이 높음 |
| 단점 | - 페이지 전환 느림
- 서버 부담 ↑
- 사용자의 인터랙션 제약 | - 초기 로딩 느림
- SEO 불리
- JS 의존도 높음, 스크립트 비대 |

하지만 2018년~2020년쯤부터는 점점 과하게 비대해지는 자바스크립트, 검색엔진 불리함으로 인해 SSR이 부활하고 점점 SSR + CSR 을 혼용하는 방식이 사용되고 있음.
React(CSR 사용)와 같은 라이브러리들을 사용하되 필요할 땐 SSR도 지원하는 방식.
요즘 개발자 구인 공고 필요 스택에서 자주 보이는 Next.js가 리액트 기반으로 SSR도 지원하는 프레임워크이다.

### JSON(JavaScript Object Notation)

JSON = 서버와 클라이언트가 데이터를 주고받을 때 사용하는 데이터 포맷. 자바스크립트의 객체 문법을 따르지만 모든 언어에서 읽고 쓸 수 있다.
각 데이터는 문자열 형태로, 쌍따옴표만을 사용해 나타내며 마지막 요소에는 콤마(`,`)를 찍어서 안 된다. 

```jsx
{
    "name": "식빵",
    "family": "웰시코기",
    "age": 1,
    "weight": 2.14
}
```

자바스크립트는 객체 기반 구조이므로 객체 데이터가 가장 다루기 쉽다.
때문에 데이터 전달 시에도 객체에 담아 전달하는 경우가 많은데 이를 서버에 그대로 보내려고 하면 문제가 생긴다.
서버 측에서는 서버만의 환경이 있어 데이터를 이해 못할 수 있기 때문이다.

그래서 클라이언트랑 서버처럼 다른 환경에서 데이터를 주고받을 때 표준화된 포맷이 필요해졌는데, 이는 가장 편하고 빠른 문자열 형태로 채택되었다.

### 직렬화라는 용어를 쓰는 이유

용어를 외우는 게 아닌 일단 이해해서 알아 놓으면 나중에 기술면접같은데서 있어보일 수 있기 때문에 정리해봄 ㅎ

- 직렬화: 객체를 JSON으로 변환하듯이(`JSON.stringfy`) 복잡한 구조를 문자열로 바꾸는 것
- 역직렬화: JSON을 객체로 변환하듯이(`JSON.parse`) 문자열을 구조적인 데이터로 바꾸는 것

근데 왜 직렬화라는 단어를 쓸까?

문자열은 정해진 구조 없이 무조건 일렬이다.
책을 읽을 때 1페이지를 읽기 위해 30페이지를 읽고 와야 되는 경우는 없는 것처럼 말이다.
반면 배열이나 객체는 복잡한 데이터 구조이다. 이러한 데이터 구조를 일렬인 문자열로 ‘펼치는’ 것이므로 직렬화라는 단어를 쓴다.

### HTTP 응답 코드의 종류

웹에서 클라이언트(브라우저)가 서버에게 요청을 보내면 서버는 응답으로 숫자 코드를 알려준다.
이 코드는 요청의 처리 상태를 나타내며, 알아두면 좋을 코드들은 다음과 같다.

- 1xx
    - 내부적으로 처리하는 정보성 코드. 실무에서 볼 일 없음.
- 2xx
    - 응답 성공
        
        
        | 200 | OK | 요청 성공
         |
        | --- | --- | --- |
        | 201 | Created | 생성됨 |
        | 204 | No Content | 응답 없음 |
- 3xx
    - 리디렉션
        
        
        | 301 | Moved Permanently | 영구 이동 |
        | --- | --- | --- |
        | 302 | Found | 임시 이동 |
        | 304 | Not Modified | 변경 없음(캐싱) |
- 4xx
    - 클라이언트 오류
        
        
        | 400 | Bad Request | 요청 잘못됨 |
        | --- | --- | --- |
        | 401 | Unauthorized | 인증 안됨 |
        | 403 | Forbidden | 접근금지 |
        | 404 | Not Found | 못 찾겠음 |
        | 409 | Conflict | 충돌남 |
- 5xx
    - 서버 오류
        
        
        | 500 | Internal Server Error | 서버 내부 오류 |
        | --- | --- | --- |
        | 502 | Bad Gateway | 게이트웨이 오류 |
        | 503 | Service Unavailable | 서비스 불가(서버 과부화 등) |

# 2회차/3주차 스터디 내용 요약

## 프로미스(Promise) 요약

자바스크립트의 비동기 처리는 전통적으로 콜백 함수를 사용했으나, 이는 **콜백 헬(callback hell)**로 인한 가독성 저하와 에러 처리의 어려움이라는 고질적인 문제를 가졌음. ES6에서 이를 보완하기 위해 **프로미스(Promise)**가 도입됨.

### 콜백 패턴의 문제점

- **콜백 헬 (Callback Hell)**: 비동기 처리 결과를 가지고 또 다른 비동기 함수를 호출하는 과정이 중첩되면 코드가 깊어져 가독성이 매우 나빠지고 실수를 유발하기 쉬움.
- **에러 처리의 한계**: try...catch 구문은 비동기적으로 실행되는 콜백 함수 내부에서 발생한 에러를 잡지 못함. 에러는 호출 스택의 아래 방향으로 전파되는데, 비동기 콜백이 실행되는 시점에는 이미 해당 콜백을 등록한 함수의 실행 컨텍스트가 스택에서 사라진 후이기 때문임.

### 프로미스란?

**프로미스는 비동기 작업의 '결과를 약속하는' 객체**임. 온라인 쇼핑 주문서가 처음엔 '처리 중' 상태였다가 나중에 '배송 완료' 또는 '주문 취소'가 되는 것과 같음. 이 약속(객체)은 아래의 세 가지 상태 중 하나를 가짐.

- pending(대기): 비동기 처리가 아직 끝나지 않은, 약속의 결과가 정해지지 않은 초기 상태임.
- fulfilled(이행): 비동기 처리가 성공적으로 완료된 상태. resolve 함수가 호출되면 이 상태가 되며, 약속된 결과값을 갖게 됨.
- rejected(거부): 비동기 처리가 실패한 상태. reject 함수가 호출되면 이 상태가 되며, 실패 원인(에러)을 갖게 됨.

fulfilled 또는 rejected 상태를 합쳐 **settled (처리됨)** 상태라고 하며, 일단 settled 상태가 되면 더 이상 다른 상태로 변경되지 않음.

### 프로미스 생성 및 사용법

- **생성**: new Promise((resolve, reject) => { ... })로 생성함. 이 생성자 함수 안에서 비동기 로직(예: 서버 요청)을 수행하고, 성공하면 resolve결과값을, 실패하면 reject에러를 호출해서 약속의 결과를 결정함.

- **후속 처리**: 프로미스의 가장 큰 장점은 후속 처리 메서드들임. 이 메서드들은 모두 **새로운 프로미스를 반환**하기 때문에, 콜백 헬 없이 깔끔한 **프로미스 체이닝(Promise Chaining)**이 가능함.

  - .then(onFulfilled, onRejected): 프로미스가 fulfilled 되면 onFulfilled 함수가, rejected 되면 onRejected 함수가 실행됨. 여기서 onFulfilled가 반환하는 값은 다음 .then으로 전달됨.
  - .catch(onRejected): rejected 상태일 때만 실행되며, then(undefined, onRejected)와 동일하게 동작함. 체인 중간에 발생하는 모든 에러를 한곳에서 처리할 수 있어 매우 유용함.
  - .finally(onFinally): 성공/실패 여부와 상관없이 무조건 한 번 실행됨. 공통적인 마무리 작업에 사용하기 좋음.

### 프로미스의 정적 메서드

- Promise.all(iterable): 여러 프로미스를 **동시에 병렬**로 처리하고 싶을 때 사용함. 모든 프로미스가 fulfilled 되어야 성공하며, 결과값을 배열에 담아 반환함. **하나라도 rejected 되면 즉시 전체가 실패**하고 해당 에러를 반환함.
- Promise.race(iterable): 여러 프로미스 중 **가장 먼저 settled 상태가 된 프로미스 하나**의 결과를 그대로 따라감.
- Promise.allSettled(iterable): Promise.all과 비슷하지만, 중간에 실패하는 프로미스가 있어도 중단하지 않고 **모든 프로미스가 settled 될 때까지 기다림**. 각 프로미스의 성공/실패 결과를 담은 객체 배열을 반환해줘서, 여러 작업의 성공 여부를 각각 확인하고 싶을 때 유용함.

### 마이크로태스크 큐와 fetch

- **마이크로태스크 큐 (Microtask Queue)**: 프로미스의 후속 처리 메서드(.then, .catch 등)의 콜백은 일반 태스크 큐보다 **우선순위가 훨씬 높은** 마이크로태스크 큐에 저장됨. 이벤트 루프는 콜 스택이 비면, 태스크 큐의 작업을 처리하기 전에 마이크로태스크 큐를 먼저 모두 비움. Promise.resolve().then(...)이 setTimeout(..., 0`보다 항상 먼저 실행되는 것이 그 증거.
- **fetch**: XMLHttpRequest를 대체하는 현대적인 Web API로, 프로미스를 기반으로 동작함. 중요한 특징은 **HTTP 상태 코드가 404나 500이더라도 네트워크 통신 자체는 성공했기 때문에 reject를 호출하지 않는다는 점**임. 대신 ok 상태가 false인 Response 객체로 resolve하므로, 아래처럼 response.ok를 직접 확인하는 에러 처리가 반드시 필요함.
  ```javascript
  fetch(...)
    .then(res => {
      if (!res.ok) throw new Error('HTTP 에러 발생!');
      return res.json();
    })
  ```

---

## 제너레이터와 async/await 요약

프로미스가 콜백 헬을 해결했다면, 제너레이터와 async/await는 비동기 코드를 **거의 동기 코드처럼 보이게** 만들어 가독성을 극적으로 향상시키는 개념임.

### 제너레이터(Generator)

ES6에 도입된 제너레이터는 **실행을 중간에 멈췄다가 원하는 시점에 다시 시작할 수 있는** 특별한 함수임.

- **정의**: function 키워드로 선언하며, 내부에 하나 이상의 yield 표현식을 포함함.

- **특징 및 동작 방식**:

  - **제어권 양도**: 일반 함수는 호출되면 끝까지 실행되지만, 제너레이터는 yield 문을 만나면 실행을 멈추고 제어권을 호출자에게 양도함.
  - **양방향 소통**:
    - next(): 호출자는 next() 메서드로 제너레이터를 재개시키고, yield된 값을 { value: ..., done: ... }` 형태로 받아올 수 있음.
    - next(인수): 반대로 next(인수)를 통해 제너레이터 **내부로 값을 전달**할 수도 있음. 멈춰있던 yield 표현식이 next가 전달한 인수로 대체되는 방식으로 동작함.
  - **에러 주입**:
    - throw(에러): 호출자는 throw() 메서드를 사용해 제너레이터 **내부로 에러를 주입**할 수도 있음. 제너레이터는 내부의 try...catch 문으로 이 에러를 잡아서 처리하는 것이 가능함.
  - **제너레이터 객체 반환**: 제너레이터 함수를 호출하면 즉시 실행되는 것이 아니라, 이터러블(iterable)이면서 이터레이터(iterator)인 **제너레이터 객체**를 반환함.

- **활용**: 이 특성들을 이용하면 비동기 작업을 동기적인 코드 흐름처럼 작성할 수 있지만, '제너레이터 실행기'라는 별도의 헬퍼 함수가 필요해 코드가 복잡해지는 단점이 있음.

### async/await

ES8(2017)에 도입된 async/await는 제너레이터의 복잡한 실행 방식을 아주 간단하고 가독성 좋게 만든, **프로미스 기반의 세련된 문법(Syntactic Sugar)**임.

- **async 함수**: 함수 앞에 async 키워드를 붙여 선언하며, 이 함수는 **언제나 프로미스를 반환**함. 만약 함수가 일반 값을 반환하면, 그 값으로 resolve된 프로미스를 대신 반환함.

- **await 키워드**:

  - **반드시 async 함수 내부에서만** 사용 가능함.
  - 프로미스 앞에 위치하며, 해당 프로미스가 settled 상태가 될 때까지 **async함수의 실행을 일시 중지**시킴. (프로그램 전체를 멈추는 것이 아님)
  - 프로미스가 fulfilled되면 그 결과값을 반환하고, rejected되면 에러를 던짐(throw).

- **에러 처리**: async/await의 가장 큰 장점 중 하나로, 비동기 코드에서 발생한 에러를 일반적인 동기 코드처럼 **try...catch 구문으로 잡을 수 있음.** await가 프로미스의 실패(rejection)를 일반적인 에러처럼 던져주기 때문에, 비동기/동기 에러를 한곳에서 처리하는 것이 가능해짐.

- **주의점**: 서로 의존하지 않는 여러 개의 비동기 작업을 await로 순차적으로 처리하면 불필요한 대기 시간이 발생함. 이럴 땐 **Promise.all을 await와 함께 사용**해서 병렬로 처리하는 것이 훨씬 효율적임.

  ```javascript
  - 비효율적인 순차 처리
  const user = await getUser();
  const posts = await getPosts();

  - 효율적인 병렬 처리
  const [user, posts] = await Promise.all([getUser(), getPosts()]);
  ```

## 에러 처리 요약

### 에러 처리의 필요성

에러가 발생하지 않는 코드를 작성하는 것은 불가능함. 따라서 코드 실행 중 발생하는 에러에 대처하지 않고 방치하면 프로그램은 강제 종료됨.

**try...catch** 문을 사용해 발생한 에러에 적절히 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있음.

또한, 직접적인 에러는 아니지만 에러로 이어질 수 있는 **예외적인 상황**도 존재함. 예를 들어 **document.querySelector**가 요소를 찾지 못하면 에러 대신 **null**을 반환하는데, 이때 후속 처리를 제대로 하지 않으면 **TypeError**가 발생할 수 있음. **옵셔널 체이닝 연산자(?.)** 등을 사용하면 이런 상황을 예방할 수 있음.

결론적으로, 코드에서 에러나 예외적인 상황이 발생할 수 있다는 것을 전제하고 이에 대응하는 코드를 작성하는 것이 매우 중요함.

---

### try...catch...finally 문

**try...catch...finally** 문은 에러 처리를 위한 대표적인 구문임.

- **try 블록**: 실행할 코드를 작성하는 부분으로, 에러가 발생할 가능성이 있는 코드를 여기에 둠.
- **catch(err) 블록**: **try** 블록에서 에러가 발생하면 실행되는 부분임. 파라미터(예: **err**)에는 발생한 **Error** 객체가 전달됨.
- **finally 블록**: 에러 발생 여부와 상관없이 **반드시 한 번 실행**되는 부분으로, 주로 자원 해제 등 공통적인 마무리 작업에 사용됨.

이 구문을 통해 에러를 처리하면 프로그램이 강제 종료되는 것을 막고 코드의 실행 흐름을 정상적으로 이어나갈 수 있음.

---

### Error 객체

자바스크립트는 에러를 나타내는 **Error** 객체를 제공함. **Error** 생성자 함수는 에러에 대한 상세 설명을 인수로 받아 에러 객체를 생성함.

- const error = new Error('에러 메시지');

에러 객체는 주로 두 가지 프로퍼티를 가짐.

- **message**: 생성자 함수에 인수로 전달한 에러 메시지.
- **stack**: 에러를 발생시킨 콜 스택의 호출 정보를 나타내는 문자열로, 디버깅에 유용함.

자바스크립트에는 기본적인 **Error** 외에도 특정 상황에 맞는 6가지의 에러 생성자 함수가 더 있음.

- **SyntaxError**: 문법에 맞지 않는 코드를 해석할 때 발생.
- **ReferenceError**: 참조할 수 없는 식별자를 참조했을 때 발생.
- **TypeError**: 피연산자나 인수의 데이터 타입이 유효하지 않을 때 발생.
- **RangeError**: 숫자 값이 허용 범위를 벗어났을 때 발생.
- **URIError**: **encodeURI**나 **decodeURI** 함수에 부적절한 인수를 전달했을 때 발생.
- **EvalError**: **eval** 함수에서 발생하는 에러.

---

### throw 문

**new Error()**로 에러 객체를 생성하는 것만으로는 에러가 발생하지 않음. 에러를 실제로 발생시키려면 **throw** 문을 사용해 에러 객체를 던져야 함.

- throw new Error('문제가 발생했습니다');

**try** 블록에서 **throw** 문이 실행되면, 코드 실행이 즉시 중단되고 던져진 에러 객체는 **catch** 블록의 파라미터에 할당됨. 이를 통해 개발자는 특정 조건에서 의도적으로 에러를 발생시키고, 이에 대한 처리를 **catch** 블록에 위임할 수 있음.

---

### 에러의 전파

에러는 **호출자(caller) 방향으로 전파**됨. 즉, 함수 호출 체인을 따라 콜 스택의 아래 방향(자신을 호출한 함수 방향)으로 에러가 전달됨.

**baz()**가 **bar()**를, **bar()**가 **foo()**를 호출하는 상황에서 **foo()**가 에러를 던지면, 이 에러는 **foo()**에서 **bar()**로, 다시 **baz()**로 전파됨. 이 과정 중 어디에서도 에러를 catch 하지 않으면 프로그램은 강제 종료됨. 만약 **baz()**를 호출한 코드 블록이 try...catch 문으로 감싸져 있다면, 에러는 거기서 최종적으로 처리됨.

단, **setTimeout**이나 프로미스 후속 처리 메서드의 콜백 함수는 이 전파 방식이 적용되지 않음. 이들은 이벤트 루프에 의해 실행될 때, 콜 스택의 최상단에 호출자가 없는 상태로 실행되기 때문에 에러를 전파할 호출자가 존재하지 않음.

# 2회차 | 프로미스, async/await, 에러처리

## **45장_프로미스** <br />
비동기 처리를 위한 패턴에는 두 가지가 있다.
1. 전통적인 방식인 `콜백 함수`
2. ES6 에서 등장한 `프로미스 (Promise)`

### 콜백 함수
- 비동기 처리를 위한 전통적인 방법
- 콜백 헬로 인한 가독성 저하
- 비동기 처리 중 발생하는 에러 처리에 유연하지 못함
- 여러 비동기 처리를 한 번에 진행하는데 어려움 발생

### 프로미스 (Promise)
- 콜백 함수의 단점을 보완함
- 비동기 처리 시점을 명확히 할 수 있음
---
그렇다면 콜백 함수의 단점을 보완한 **프로미스** 에 대해서 자세히 살펴보자

Promise 생성자 함수를 new 연산자와 함께 사용하여 호출하면 Promise 객체를 생성하게 된다.<br />
이 때, Promise 생성자 함수는 `비동기 처리` 를 수행할 `콜백 함수` 를 인수로 전달 받게 된다.  인수로 전달된 콜백 함수 또한 인수를 전달받는데, 그것은 `resolve` 와 `reject` 이다.

Promise 인수로 전달된 콜백 함수 내부에서 비동기 처리를 수행하게 된다.
- 비동기 처리 성공 -> `resolve` 함수 호출
- 비동기 처리 실패 -> `reject` 함수 호출

Promise 는 비동기 처리의 현재 처리 진행상태를 나타내는 `상태 정보 (status)` 를 가지는데, 종류는 아래와 같다. 

| 프로미스 상태정보 | 의미 | 상태 변경 조건 |
| ------------ | ---- | ------------ |
| pending | 비동기 처리가 아직 수행되지 않은 상태(기본값) | 프로미스가 생성된 직후 기본 상태 | 
| fulfilled | 비동기 처리가 수행된 상태(성공) | resolve 함수 호출(result) |
| rejected | 비동기 처리가 수행된 상태(실패) | reject 함수 호출(result)|

여기서 기본값인 pending 이 아닌 상태 즉, 비동기 처리가 수행된 상태를 의미하는 fulfilled 또는 rejected 상태를 `settled` 상태라고 한다.

**=> 프로미스는 비동기 처리 `상태` 와 `처리 결과` 를 관리하는 `객체` 이다.**

---
비동기 처리 상태가 settled 가 되면 이에 따른 후속 처리가 필요하다.<br />
이를 위해 프로미스는 후속 메서드를 제공하는데, 종류로는 `then`, `catch`, `finally` 가 있다.<br />
후속 처리 메서드에도 인수가 필요한데, 이 인수에는 프로미스의 처리 결과가 자리하게 된다.<br />
모든 후속 처리 메서드는 항상 프로미스를 반환하며 비동기로 동작한다.

이러한 후속 처리 메서드를 하나씩 살펴보자!

**1. `then` 메서드**
then 메서드는 두 개의 콜백 함수를 인수로 전달받음
- 프로미스가 fulfilled 상태일 때 호출할 콜백 함수
- 프로미스가 rejected 상태일 때 호출할 콜백 함수

**2. `catch` 메서드**
catch 메서드는 한 개의 콜백 함수를 인수로 전달받음<br />
-> 프로미스가 rejected 상태인 경우에만 호출되므로, rejected 상태일 때 호출할 콜백 함수만 인수로 전달받음

**3. `finally` 메서드**
finally 메서드는 한 개의 콜백 함수를 인수로 전달받음<br />
-> 프로미스의 성공 또는 실패와 상관없이 `무조건` 한 번 호출됨<br />
-> 프로미스의 상태와 상관없이 공통적으로 수행해야할 내용이 있을 때 유용함

위 3가지의 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적인 호출이가능하다. => 이를 **"프로미스 체이닝"** 이라고 한다.<br />
이렇게 프로미스는 프로미스 체이닝을 통하여 진행하므로 콜백 헬이 발생하지 않는다. 그렇다하더라도 프로미스도 콜백 함수를 사용하게 되는데, 이는 가독성이 좋지 않다는 단점이 있다. <br />
이 단점은 `async / await` 를 통해 해결할 수 있는데, 이 내용은 뒤에서 다뤄보도록 하자.

---
Promise 는 생성자 함수로 사용되지만, 함수도 객체이므로 메서드를 가질 수 있다. <br />
Promise 는 5가지의 정적 메서드를 제공하는데 다음과 같다.

**1. resolve**<br />
**2. reject**<br />
**3. Promise.all**
- 여러 비동기 처리를 병렬로 처리할 때 사용
- 모든 프로미스 상태가 fulfilled 가 되면 종료
- 처리 순서가 보장됨
- 인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태가 되면 즉시 종료되고 에러를 reject 하는 새로운 프로미스를 반환함

**4. Promise.race**
 - all 메서드처럼 프로미스를 요소로 갖는 `배열` 을 인수로 받음
 - 가장 먼저 fulfilled 가 된 프로미스의 결과를 resolve 함 
 - 전달받은 프로미스가 하나라도 rejected 되면 all 메서드와 동일하게 처리됨
 
**5. Promise.allSettled**
- 프로미스를 요소로 갖는 `배열` 을 인수로 받음
- 프로미스가 모두 `settled` 상태가 되면 처리결과를 배열로 반환함
---
### 마이크로태스크 큐
> 프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아닌 마이크로태스트 큐에 저장됨

- 마이크로태스크 큐: 프로미스의 후속 처리 메서드의 콜백 함수 일시 저장되는 곳
- 태스크 큐: 비동기 함수의 콜백 함수, 이벤트 핸들러 일시 저장되는 곳

**마이크로태스크 큐는 태스크 큐보다 우선순위가 `높다`**<br />
-> 이벤트 루프는 콜 스택이 비었을 때, 마이크로태스크 큐에서 대기하고 있는 함수를 먼저 실행한다. 이 후 마이크로태스크 큐가 비었다면 그 때, 태스크 큐에 대기하고 있는  함수를 실행한다.

---
### fetch 함수
> HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API

```const Promise = fetch(url[,options])``` 

- 전달: 요청전송할 url, HTTP 요청 메서드(*GET/POST/PATCH/DELETE*), HTTP 요청 헤드, 페이로드
- 반환: Response 객체를 래핑한 Promise 객체<br />
	-> 에러가 발생해도 에러를 reject 하지 않고, 불리언(boolean) 타입의 상태(status) 를 false 로 설정한 Response 객체를 resolve 함<br />
    (오프라인 등의 네트워크 장애나 CORS 에러에 의한 경우에만 프로미스를 reject 함)
    

다음 장에서는 **제너레이터와 async/await** 에 대해서 알아보자!

## **46장_제너레이터와 async/await** <br />

제너레이터란?
`function*` 키워드로 선언하는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수

그렇다면 일반 함수와 어떤 점이 다를까?<br />
**1. 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.**<br />
**2. 함수 호출자와 함수의 상태를 주고받을 수 있다.**<br />
**3. 제너레이터 객체를 반환한다.**

제너레이터 함수를 정의하는 방법
- `function*` 키워드로 선언
- 하나 이상의 `yield` 표현식 포함
- 위 두 가지 외에는 일반 함수와 동일

제너레이터 함수 특징
- 화살표 함수로 정의 할 수 없음
- new 연산자를 이용하여 생성자 함수 호출을 할 수 없음
---
### 제너레이터 객체
>함수 코드블록을 실행하는 일반 함수와는 달리 제너레이터 함수는 호출시 재너레이터 객체를 생성해 반환함
-> 재너레이터 객체는 `이터러블` 인 동시에 `이터레이터` 이다.

**제너레이터 객체의 특징**
- Symbol.iterator 메서드를 상속받음
- `next` 메서드(*value(yield값), done(false값) 프로퍼티를 갖는 result 객체를 반환)를 소유함 -> 별도로 이터레이터를 생성할 필요 ❌
- 이터레이터에는 없는 `return`, `throw` 메서드를 가짐
  - `result` 메서드의 경우 <br />
인수로 전달받은 값=>value 프로퍼티 값,
true => done 프로퍼티 값으로 가짐
  - `throw` 메서드의 경우<br />
인수로 전달받은 에러 발생 시킨 후 undefined => value 프로퍼티 값, <br />
true => done 프로퍼티 값으로 가짐

재너레이터는 yield 키워드와 next 메서드를 통해 실행 일시중지 및 재개를 진행하는데, 이 점이 일반 함수와 다른 점이다. <br />
일반 함수는 호출 이후 제어권을 함수가 `독점`하지만, 제너레이터는 함수 호출자에게 제어권을 `양도` 하는 개념인 것이다.<br />
일반 함수와 또 다른 점은 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라, `yield` 표현식까지만 실행한다는 것이다.<br />
즉, `yield` 가 통행 결정권을 쥐고 있다고 볼 수 있다. `yield` 키워드가 제너레이터 함수 실행을 일시 정지 시킬 수도 있고, 키워드 뒤에 오는 표현식의 결과를 함수 호출자에게 반환할 수도 있는 것이다.

정리해보면,<br />
제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수상태를 주고 받을 수 있다. <br />
이런 특성을 활용하면 `프로미스` 를 사용한 비동기처리를 후속 처리 메서드인 `then`, `catch`, `finally` 없이 동기처리처럼 구현할 수도 있다.

---
### async / await
> ES8(ECMAScript 2017) 에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 구현되도록 할 수 있는 방법

**async / await 특징**
- 프로미스를 기반으로 동작함
- 프로미스의 후속 처리 메서드에 콜백 함수를 전달할 필요없이, 동기 처리처럼 프로미스를 사용할 수 있음

**1. async 함수**
> async 키워드를 사용하여 정의하며, 언제나 프로미스를 반환함

async 함수는 명시적으로 프로미스를 반환하지 않더라도 `암묵적`으로 반환값을 resolve 하는 `프로미스`를 반환하게 되어있다.
더불어, `await` 키워드는 반드시 `async` 함수 내부에서만 사용해야 한다.

**2. await 함수**
> 프로미스가 settled 상태가 될 때까지 대기하다가 해당 상태가 되면 프로미스가 resolve한 처리 결과를 반환함

await 키워드는 반드시 프로미스 `앞` 에서 사용해야 한다.
즉, await 키워드는 다음 실행을 `일시 중지` 시켰다가 프로미스가 `settled` 상태가 되면 `재개` 시킨다고 보면 된다.
대신 모든 포르미스에 await 키워드를 사용하는 것은 지양해야하는데, 서로 연관성없이 개별적으로 수행되는 비동기 처리마다 키워드를 사용하게 되면 처리 시간이 늘어나므로 이럴 때는 Promise.all에 한 번만 키워드를 사용하는 것이 효율적이다. 

> **await 관련 내용정리**
> 처리 순서가 보장되어야하는 비동기 처리에는 키워드를 사용하고, 처리 순서의 보장이 필요하지 않을 경우에는 일일히 키워드를 붙여서 사용하지 말자

### 46장을 마치며...
45장.프로미스에서 살짝 살펴본 콜백 함수의 단점 중 하나가 에러처리가 어렵다는 것이였다. 
그렇다면 async / await 에서의 에러처리는 어떨까?
`async / await` 에서의 에러 처리는 `try...catch` 문을 사용한다. 비동기 함수는 프로미스를 반환하므로 호출자가 명확하기 때문이다. 

에러 처리 관련한 내용은 다음 장인 47장에서 조금 더 다뤄보도록 하겠다.

## **47장_에러 처리** <br />

**어떤 코드를 작성하든 에러가 발생하지 않는 코드를 작성하기란 불가능하지 않을까?**

에러는 언제든 발생할 수 있기 때문에 어떻게하면 에러를 발생시키지 않을 수 있을까를 고민하기보다 올바른 대처방법을 알고 있는 것이 더 중요하고 필요하다고 생각된다.

그렇다면 에러 발생을 대처할 수 있는 방법에는 어떤 것들이 있는지 살펴보자.

### 1. try...catch...finally 문
> 에러 처리 코드를 미리 등록해두고 에러가 발생하면 등록해둔 에러 처리 코드로 이동하는 방법

`try...catch...finally` 문은 3개의 코드 블록으로 구성되어 있으며, finally는 불필요하다면 생략가능하다. catch도 생략은 가능하지만 catch 없이 try 만 있는 문은 의미가 없으므로 try, catch 는 필수적으로 작성되어야 한다.

`try...catch...finally` 문은 아래 순서로 실행이 된다. <br />
1️⃣ try 코드 블록이 실행된다. <br />
2️⃣ 에러가 발생하면 catch 문의 변수로 전달되고, catch 코드 블록이 실행된다. <br />
3️⃣ 에러 발생여부와 상관없이 finally 코드 블록이 실행된다. <br />
```
try {
	// 실행할 코드
} catch(err) {
	// 에러 발생시 실행할 코드
    // err 는 try 에서 발생한 Error 객체가 전달됨
} finally {
	// 에러 발생여부와 상관없이 실행할 코드 (반드시 한 번 실행됨)
}
```

이렇게 에러 처리를 하면 프로그램이 강제 종료될 일은 없다.

### 2. Error 객체
Error 생성자 함수는 `에러 객체`를 `생성`하며, 이 함수에는 에러를 설명해주는 `에러 메세지` 를 인수로 전달할 수 있다.
`const error = new Error('에러 메세지');`

자바스크립트는 에러 객체를 생성하는 Error 생성자 함수를 포함해 총 7가지의 에러 객체를 생성할 수 있는데, 종류는 다음과 같다.

|생성자 함수| 인스턴스 |
|--------| -------|
|Error | 일반적인 에러 객체|
|SyntaxError | 문법오류를 발생하는 에러 객체|
|ReferenceError | 참조 오류를 발생하는 에러 객체|
|TypeError | 데이터 타입이 유효하지 않을때 발생하는 에러 객체|
|RangeError | 허용 범위를 벗어났을 때 발생하는 에러 객체|
|URIError | 함수에 부적절한 인수를 전달했을 때 발생하는 에러 객체|
|EvalError | eval 함수에서 발생하는 에러 객체|

### 3. throw 문
위에서 살펴본 Error 객체는 에러 객체를 `생성` 하는 것이지, 에러가 `발생` 하는 것은 아니다. 즉, 에러 객체 생성과 에러 발생은 다른 의미이다. (`≠`)

에러가 발생되어야 에러 객체도 제기능
을 할텐데, 그렇다면 에러 발생은 어떻게 이루어지는 걸까?

에러를 발생시키려면 try 코드 블록에서 `throw` 문으로 에러 객체를 던져야한다.
try 코드 블록에서 `throw` 문으로 에러를 던지면 `catch` 문에서 탁! 잡고서 코드 블록이 샐행된다. ~~나이스캐치~~

이렇듯 에러는 나이스하게 잡아줘야 한다.
에러는 캐치하지 않으면 호출자 방향으로 전파되는 특성을 가지고 있는데, 에러를 어디에서도 캐치하지 않으면 프로그램이 강제 종료되는 상황에까지 이르게 되므로 주의하자!

## 생성자 함수에 의한 객체 생성

객체 리터럴은 가장 일반적이고 간단한 객체 생성 방식이지만, 동일한 프로퍼티 구조를 가진 객체를 여러 개 만들 때는 비효율적인데, 매번 같은 프로퍼티와 메서드를 반복해서 기술해야 하기 때문. 이러한 문제점을 해결하기 위해 생성자 함수를 사용한다. 생성자 함수는 객체를 생성하기 위한 템플릿(클래스)처럼 동작하여, 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있게 해줌

### 생성자 함수의 동작 원리

일반 함수와 생성자 함수의 형식적인 차이는 없으며, new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. new 연산자로 생성자 함수를 호출하면, 함수 내부에서는 다음과 같은 과정이 암묵적으로 처리된다.

    1. 인스턴스 생성과 this 바인딩: 빈 객체가 암묵적으로 생성되고, 이 객체(인스턴스)는 this에 바인딩된다.

    2. 인스턴스 초기화: 함수 본문의 코드가 실행되면서 this에 바인딩된 인스턴스에 프로퍼티와 메서드를 추가하고 초기화한다.

    3. 인스턴스 반환: 완성된 인스턴스가 암묵적으로 반환된다. 만약 다른 객체를 명시적으로 반환하면 그 객체가 반환되지만, 원시 값을 반환하면 무시되고 this가 반환된다. 따라서 생성자 함수 내부에서는 return 문을 생략하는 것이 기본 원칙.

함수 호출 방식에 따라 this가 가리키는 대상이 달라지는데, 생성자 함수로 호출될 경우 this는 앞으로 생성될 인스턴스를 가리킨다.

### 함수 객체의 내부 메서드

함수는 호출할 수 있는 객체다. 모든 함수 객체는 호출될 때 사용되는 내부 메서드 [[Call]]을 가지고 있어 callable이라고 불린다. 이 중 new 연산자와 함께 호출되어 인스턴스를 생성할 수 있는 함수들은 내부 메서드 [[Construct]]도 가지고 있으며, 이런 함수를 constructor라고 한다. 반면 [[Construct]]를 갖지 않는 함수는 non-constructor다. 함수 선언문, 함수 표현식, 클래스로 정의된 함수는 constructor이다. 하지만 화살표 함수나 ES6 메서드 축약 표현으로 정의된 함수는 non-constructor이므로 new 연산자로 호출할 수 없다.

### new 연산자와 new.target

new 연산자 없이 생성자 함수를 호출하면 일반 함수로 동작하여 this가 전역 객체(window)를 가리키게 되므로 오류가 발생할 수 있다.이러한 실수를 방지하기 위해 ES6에서는 new.target을 지원한다. 함수가 new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고, 일반 함수로 호출되면 undefined가 된다. 이를 통해 함수 내부에서 new 호출 여부를 확인하고, new 없이 호출되었다면 재귀적으로 new를 붙여 호출하도록 강제할 수 있다. new.target을 지원하지 않는 환경에서는 this instanceof Circle과 같은 스코프 세이프 생성자 패턴을 사용할 수 있다.

## 프로토타입

자바스크립트는 프로토타입 기반의 객체지향 언어임. 객체지향의 핵심 개념 중 하나는 상속인데, 자바스크립트는 이 상속을 프로토타입을 통해 구현함. 상속은 코드 재사용성을 높여 불필요한 중복을 제거하는 매우 중요한 개념임.

### 상속과 프로토타입의 필요성

생성자 함수를 통해 여러 개의 객체(인스턴스)를 만들 때, 모든 인스턴스가 공통으로 사용할 메서드를 생성자 함수 내부에 정의하면 문제가 발생함. 인스턴스를 생성할 때마다 똑같은 내용의 메서드가 계속 새로 만들어져 메모리를 불필요하게 낭비하기 때문임. 이 문제를 해결하기 위해 프로토타입을 사용함. 모든 인스턴스가 공유해야 할 프로퍼티나 메서드를 프로토타입이라는 공통의 부모 객체에 미리 만들어두는 것임. 그러면 모든 인스턴스는 이 프로토타입을 상속받아, 마치 자신의 것처럼 해당 메서드를 공유해서 사용할 수 있음. 이렇게 하면 메서드는 단 한 번만 생성되므로 메모리를 효율적으로 사용할 수 있음.

### 프로토타입 객체의 핵심 요소들

[슬라이드7]
책에서는 생성자, 프로토타입 객체, 인스턴스의 관계를 상당히 주의깊게 설명하고 있습니다.

모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 슬롯은 자신의 부모 객체, 즉 프로토타입을 가리킴. 이 관계를 이해하려면 몇 가지 중요한 프로퍼티를 알아야 함.

    __proto__ 접근자 프로퍼티: 모든 객체가 가지고 있으며, 자신의 [[Prototype]] 내부 슬롯(즉, 자신의 프로토타입)에 접근할 수 있게 해줌. __proto__를 직접 사용하는 것보다는 Object.getPrototypeOf() 와 Object.setPrototypeOf() 메서드를 사용하는 것이 더 권장됨.

    prototype 프로퍼티: 함수 객체만이 가지는 프로퍼티임. 이 프로퍼티는 그냥 프로토타입 객체를 가리키는 것이 아니라, 이 생성자 함수가 앞으로 생성할 인스턴스들의 프로토타입이 될 객체를 가리킴.

    constructor 프로퍼티: prototype 객체 자신이 가지고 있는 프로퍼티로, 자신을 prototype으로 참조하는 생성자 함수를 다시 가리킴.

결론적으로, **"인스턴스의 `__proto__`"**와 **"생성자 함수의 prototype"**은 결국 동일한 프로토타입 객체를 가리킴. 그리고 그 프로토타입 객체의 constructor는 다시 생성자 함수를 가리키며, 이 세 요소는 서로 긴밀하게 연결되어 있음.

### 프로토타입 체인

자바스크립트는 객체의 프로퍼티나 메서드에 접근할 때, 만약 그 객체 자신에게 해당 프로퍼티가 없으면, **proto**가 가리키는 부모 객체(프로토타입)를 순차적으로 거슬러 올라가며 검색함. 이 연결 구조를 프로토타입 체인이라고 부름. 이것이 자바스크립트 상속의 핵심 원리임. 이 체인의 최상위에는 항상 Object.prototype이 존재함. 따라서 자바스크립트의 모든 객체는 Object.prototype을 상속받고, 여기서 제공하는 hasOwnProperty, toString 같은 기본 메서드들을 사용할 수 있는 것임. 만약 체인의 끝까지 프로퍼티를 찾지 못하면, 에러가 아니라 undefined를 반환함.

### 오버라이딩과 프로퍼티 섀도잉

만약 인스턴스에 프로토타입이 가진 프로퍼티와 같은 이름의 프로퍼티를 추가하면, 프로토타입의 프로퍼티가 수정되는 것이 아니라 인스턴스에 새로운 프로퍼티가 생성됨. 이 인스턴스 프로퍼티는 프로토타입의 프로퍼티를 덮어쓰게 되는데, 이를 오버라이딩이라고 함. 이때, 프로토타입 프로퍼티는 인스턴스 프로퍼티에 의해 가려지게 되는데, 이 현상을 프로퍼티 섀도잉이라고 부름.

### 프로토타입의 교체

프로토타입은 다른 임의의 객체로 동적으로 교체할 수 있음. 하지만 주의할 점이 있음. 생성자 함수의 prototype을 단순한 객체 리터럴로 교체해 버리면, 교체된 객체에는 constructor 프로퍼티가 없기 때문에 생성자 함수와 프로토타입 간의 연결이 끊어지게 됨. 이 연결을 유지하려면, 교체할 객체 리터럴 내부에 constructor 프로퍼티를 명시적으로 추가해서 다시 생성자 함수를 가리키도록 설정해줘야 함.

### 정적 프로퍼티와 프로토타입 프로퍼티

    정적(static) 프로퍼티/메서드: 생성자 함수 객체에 직접 추가한 프로퍼티나 메서드임. 이들은 인스턴스가 상속받는 것이 아니므로, 인스턴스를 통해서는 접근할 수 없고 오직 생성자 함수 자체를 통해(Person.staticMethod()) 접근해야 함. Object.create나 Object.keys가 대표적인 정적 메서드임.

    프로토타입 프로퍼티/메서드: 생성자 함수의 prototype 객체에 추가한 프로퍼티나 메서드임. 이들은 모든 인스턴스가 상속받기 때문에, 인스턴스를 통해(me.sayHello()) 접근할 수 있음.

### 프로퍼티 존재 확인 및 열거

    in 연산자: 객체에 특정 프로퍼티가 있는지 확인할 때 사용함. 객체 자신의 프로퍼티뿐만 아니라, 프로토타입 체인 상에 존재하는 모든 프로퍼티를 대상으로 확인하기 때문에 상속받은 프로퍼티에 대해서도 true를 반환함.

    Object.prototype.hasOwnProperty: in 연산자와 달리, 상속받은 프로퍼티는 무시하고 오직 객체 자신이 직접 소유한 프로퍼티인 경우에만 true를 반환함.

    for...in 문: 객체의 프로퍼티를 순회할 때 사용함. 객체 자신의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티 중 열거 가능한(enumerable) 것들까지 모두 순회함.

    Object.keys, Object.values, Object.entries: for...in과 달리 상속받은 프로퍼티는 제외하고, 객체 자신이 직접 소유한 프로퍼티 중 열거 가능한 것들만 배열로 반환함. 따라서 객체 자신의 프로퍼티만 다루고 싶을 때는 이 메서드들을 사용하는 것이 더 명확하고 안전함.

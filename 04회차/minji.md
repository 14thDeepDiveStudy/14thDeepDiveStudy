# 4회차 | 생성자 함수, 프로토타입

## **17장\_생성자 함수** <br />

객체를 생성하는 방식은 크게 2가지로 정리할 수 있을 것 같다.

1. `객체 리터럴` 에 의한 생성
2. `생성자 함수` 에 의한 생성

가장 일반적으로 쓰이고 간단한 방식은 `객체 리터럴` 방식이다.

### 생성자 함수 (_Constructor_)

#### Object 생성자 함수

> `new` 연산자와 함께 호출시 `빈 객체` 를 생성하여 반환

그렇다면 여기서 생성자 함수란 어떤 함수를 말하는 걸까?
-> `new` 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수를 통해서 생성된 객체를 `인스턴스` 라고 말한다.

자바스크립트는 `Object` 외에도 빌트인 된 생성자 함수가 있는데, 대표적으로 `String`, `Number`, `Boolean`, `Function`, `Array` 등이 있다.

#### 객체 리터럴에 의한 객체 생성

객체 리터럴에 의한 생성 방법은 아래와 같다.

```
const circle = {
	radius: 5,
    getDiameter() {
    	return 2 * this.radius
    }
}

console.log(circle.getDiater()) // 10
```

이 방식은 직관적이고 간편하다는 장점이 있는 반면, 한번에 하나의 객체만 생성할 수 있다는 단점이 있다.
즉, 객체를 여러 개 생성해야하는경우 위 식을 아래와같이 반복하여 작성해야한다는 것이다.

```
const circle1 = {
	radius: 5,
   getDiameter() {
   	return 2 * this.radius
   }
}

console.log(circle1.getDiater()) // 10

const circl2 = {
	radius: 7,
   getDiameter() {
   	return 2 * this.radius
   }
}

console.log(circle2.getDiater()) // 14

const circle3 = {
	radius: 10,
   getDiameter() {
   	return 2 * this.radius
   }
}

console.log(circle3.getDiater()) // 20
```

위 예시처럼 갯수가 많지않다면 그냥 써도 괜찮지않을까라는 생각이 들 수 있지만,
객체는 20개, 50개, 100개를 생성해야한다면...?

위 방식으로 진행하는 것은 매우 비효율적이지 않을까?
그렇다면 생성자 함수에 의한 생성방법은 어떨까

#### 생성자 함수에 의한 객체 생성

생성자 함수에 의한 생성 방법은 아래와 같다.

```
function Circle(radius) {
	this.radius = radius
    this.getDiameter = function() {
    	return 2 * this.radius
    }
}

// 인스턴스(객체) 생성
const circle1 = new Circle(5)
const circle2 = new Circle(7)

console.log(circle1.getDiameter()) // 10
console.log(circle2.getDiameter()) // 14
```

프로퍼티 구조가 동일하다면 이렇게 생성자 함수를 사용하여 동일한 객체의 생성을 간편하게 여러 개 진행할 수 있다. (~~_like 리액트 프로젝트 템플릿_~~)

객체를 생성하는 생성자 함수인데 형태를 보면 일반 함수와 차이가 없다.
그렇다면 생성자 함수로 동작하는지의 여부는 어떻게 알 수 있을까?
바로 `new` 연산자가 신호이다!
-> `new` 연산자와 함께 호출되면 `생성자 함수` 로 동작하고,
`new` 연산자와 함께 호출하지 않으면 `일반 함수` 로 동작한다.

---

### 생성자 함수의 몸(body) 에서는 어떤 일이 일어날까?

생성자 함수가 인스턴스(객체)를 생성하는 과정은 생성자 함수의 몸(body) 부분에서 정의되고 일어난다.

생성자 함수는 인스턴스를 생성하기도 하지만, 생성된 인스턴스를 초기화하는 역할도 한다.
두 가지 역할을 하지만 `인스턴스 생성` 이 필수로 진행해야하는 주업무이고 `초기화` 는 부수적인 역할(옵션)이다.

생성자 함수의 두 가지 역할이 어떤 단계에서 일어나는지 그리고 생성자 함수의 몸에서는 어떤 과정들이 일어나는지 아래 예제를 통해서 살펴보자.

```
function Circle(radius) {
	// step1. 인스턴스 생성 및 this 바인딩

	// step2. 인스턴스 초기화
    this.radius = radius
    this.Diameter = function() {
    	return 2 * this.radius
     }
    // step3. 인스턴스 암묵적 반환
}
// final. 인스턴스 생성
const circle = new Circle(5)
```

이 과정속에서 생성자 함수가 this 가 아닌 다른 `객체` 를 명시적으로 반환하면 this 는 반환되지 못하고 return 문에 명시된 객체가 반환된다. => `명시적 객체 >>>> this`
단, 명시적으로 `원시 값` 을 반환하면 원시 값은 무시되고, this 가 반환된다. => `원시 값<<<< this`

이렇게 함수 내부에 다른 경우를 명시적으로 반환시키게되면, 생성자 함수의 역할을 방해하는 것이기때문에 생성자 함수 내부에서 명시적으로 `return` 을 사용하지 말아야 한다.

### 나는 생성자 함수가 될 수 있을까? 없을까?

생성자 함수는 일반 함수형태에 `new` 연산자와 함께하느냐 안하느냐로 구분한다.
그렇다면 모든 함수를 정의하는 형태이면 `new` 연산자와 함께 생성자 함수로 호출될 수 있을까?

#### "NO!"

함수는 객체이므로 일반 객체와 동일하게 동작하고, 일반 객체가 가지고 있는 내부 슬롯과 메서드도 모두 가질 수 있다.
하지만, 일반 객체와 차별점이 있다면 그것은 `호출` 을 할 수 있다는 것이다. (~~_일반객체는 호출할 수 없음_~~)

**1. 함수 객체가 가지고 있는 특징 중 `내부 메서드` 에 대해서 먼저 살펴보자.**

함수 객체는 `[[Call]]`, `[[Construct]]` 내부 메서드를 가지고 있으며, 각 메서드는 함수가 어떤 역할로 호출되느냐에 따라 그 역할과 짝을 지어 호출된다.
이 때, 어떤 내부 메서드를 갖느냐에따라 불리는 이름이 있다.

- 일반 함수로 호출 -> `[[Call]]` 내부 메서드 호출 -> `callable` 함수 객체 <기본>
- 생성자 함수로 호출 -> `[[Construct]]` 내부 메서드 호출 -> 1️⃣ `constructor` 함수 객체(_내부 메서드를 가짐_) / 2️⃣ `non-constructor` 함수 객체(_내부 메서드를 가지지 않음_)

생성자 함수 객체 중 `non-constructor` 즉, 호출할 수 없는 객체는 일반 함수의 역할만 가능할뿐 생성자 함수의 역할은 맡을 수 없다.

근데 여기서 궁금한 점은 `constructor` 와 `non-constructor` 는 어떻게 구분할 수 있는 걸까?

#### "함수 정의 방식으로 구분해"

자바스크립트 엔진은 함수가 정의된 방식을 평가하여 `constructor` 와 `non-constructor` 를 구분한다.

| 구분              | 함수 정의 방식                   |
| ----------------- | -------------------------------- |
| `constructor`     | 함수 선언문, 함수 표현식, 클래스 |
| `non-constructor` | 메서드 정의, 화살표 함수         |

**2. 함수 객체가 가지고 있는 특징 중 `new` 연산자에 대해서 간단히 살펴보자.**

위에서도 살펴봤듯이 일반 함수와 생성자 함수는 겉모습만 봐서는 구분할 수 가 없다.
구분할 수 있는 방법은 `new` 연산자와 `함께` 호출이 되냐 아니냐인 것이다.

추가적인 구분 방법은 관례적으로 `생성자 함수` 는 첫 글자를 `대문자` 로 기술하는 것이니 알아두도록 하자!

---

### new.target

일반 함수와 생성자 함수를 구분하기위한 컨벤션으로 `new` 연산자도 붙이고, 첫 글자 `대문자` 로 적는 `파스칼 케이스` 도 사용을 하지만 누구나 실수는 할 수 있다.
그런 실수 발생 가능성을 낮추기 위해 `new.target` 을 지원한다.

**그렇다면 `new.target` 이란 뭘까?**

`constructor` 인 함수 내부에서 암묵적으로 `지역변수` 처럼 사용되며, `this` 와 유사하다.
=> 함수 내부에서 `new.target` 을 사용한다면 `생성자 함수` 로 호출되었구나~ 라고 생각해도 된다.

단, `new` 연산자와 함께 호출됐는지의 여부에 따라 `new.target` 의 의미가 달라진다.

- `new` 연산자와 함께 호출 -> 내부의 `new.target` 은 `함수자신`을 가리킴
- `new` 연산자없이 호출 -> 내부의 `new.target` 은 `undefined` ❌

`new` 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 `프로토타입` 에 의해 생성자 함수와 연결(바인딩) 되고, 이를 통해 `new` 연산자와 함께 호출되었는지를 확인할 수 있다.

**`프로토타입`에 대해서는 19장에서 살펴보도록 하자!**

## **19장\_프로토타입** <br />

프로토타입에 대해 이해하려면 먼저 `객체지향 프로그래밍` 에 대해서 알아야 한다.

### 객체지향 프로그래밍이란?

**| 여러 개의 독립적 단위, 즉 `객체` 의 집합으로 프로그램을 표현하는 패러다임**!

객체지향 프로그래밍은 특징이나 성질을 나타내는 `속성` 을 가지고 실체를 인식 또는 구별을 한다.
여기서 `속성` 은 사람을 예시로 설명을 해보자면, 자기소개를 생각하면 쉬울 것 같다.
나를 소개한다면 아래와같은 `속성` 들(_이름, 나이, 성격, 직업 등_)로 설명할 수 있을 것이다.
![](https://velog.velcdn.com/images/minji-kim0524/post/a23f4f16-eb56-4b8d-be79-cccf7577d39a/image.png)

우리에게 위와같이 다양한 속성이 있듯이 프로그래에서도 다양한 속성을 구현하고자 할 것이다.
구현하려는 프로그램에서 몇 가지 특정 속성에만 관심이 있다고 했을때,
그 관심있는 속성만 쏙쏙 빼내서 표현하는 것을 `추상화` 라고 한다.
추상화한 객체를 표현하면 다음과 같다.

```js
// person이라는 객체
const person = {
  name: "minji",
  address: "sejong",
};

console.log(person); // {name: "minji", address: "sejong"}
```

17장. 생성자 함수에서 예시로 들었던 원의 반지름을 생각해보자.

```js
const circle = {
  radius: 5, // 객체의 상태를 나타냄

  // 객체의 상태 데이터를 조작함
  getDiameter() {
    return 2 * this.radius;
  },
};
```

객체 리터럴 방식으로 생성한 위 객체를 살펴보면,
객체의 `상태` 를 나타내는 데이터(_radius_) 와 상태 데이터를 조작하는 `동작` (_getDiameter_) 으로 구성되어 있다.
즉, 객체는 `상태 데이터` 와 `동작` 을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있다.
객체지향 프로그래밍에서는 `상태 데이터` 와 `동작` 을 부르는 단어가 있다.

- `상태 데이터` -> `프로퍼티(property)`
- `동작` -> `메서드(method)`

객체는 각각 고유의 기능을 가지므로 독립적이라고 볼 수도있지만, 내 역할을 수행하면서 다른 객체들과도 관계성을 가진다.
내가 내 자신의 역할을 수행만 하지않고, 친구도 사귀고 직장에서도 동료들과 협업을 하듯 다른 객체와 상호작용을 한다.

여러 상호작용 중 먼저 `상속` 에 대해서 살펴보자.

### 상속과 프로토타입

**상속이란?**
| 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 `그대로` 사용할 수 있는 것

17장에서 살펴봤듯 생성자 함수는 동일한 구조(프로퍼티 + 메서드)를 갖는 객체를 여러 개 생성할 때 유용하다.
객테 리터럴 생성방식에도 단점이 있듯 생성자 함수에도 단점은 있다.

생성자 함수에 의한 객체를 생성할 때, 프로퍼티 값은 객체마다 다르지만 동작을 담당하는 메서드는 동일하게 적용된다.
그런데 생성자 함수가 여러 번 실행될때마다 객체마다 동일하게 적용되는 메서드도 여러 번 반복실행이 된다. 불필요하고 비효율적이라는 생각이 드는 순간이다.

이런 불필요한 중복을 제거하기 위해 등장한 것이 **[자바스크립트의 `프로토타입(prototype)` 기반으로 `상속` 구현하기]** 이다

> 프로토 타입(prototype) 은 인스턴스의 상위(부모) 객체 역할을 하며, 모든 인스턴스는 프로토 타입의 메서드를 상속받아 사용할 수 있다.

프로토 타입의 개념을 적용시켜보면, 자신의 상태를 나타내는 `프로퍼티` 만 객체마다 소유하고, 동일하게 적용되는 동작인 `메서드` 는 프로토 타입에 할당시켜놓고 공유하여 사용하도록 하는 것이다.

이렇듯 `상속` 은 코드의 재사용 측면에서 매우 유용한 개념이므로 잘 짚고 넘어가도록 하자!

### 프로토타입 객체

모든 객체는 `[[Prototype]]` 이라는 내부 `슬롯` 을 가지며, 슬롯의 값은 프로토 타입의 참조이다.
이 슬롯에 저장되는 프로토타입은 `객체 생성 방식` 에 의해 결정된다. 즉, 객체가 생성될 때 프로토 타입이 결정되고 슬롯인 `[[Prototype]]` 에 저장되는 것이다.

> 객체는 하나의 `프로토 타입` 을 갖고, 프로토 타입은 `생성자 함수` 와 연결되어있다.

위 내용을 도식화해보면 서로의 관계를 파악하기 쉬울 것 같다.

#### 접근자 프로퍼티, `__proto__`

| 모든 객체는 접근자 프로퍼티인 `__proto__` 를 통해서 자신의 프로토 타입인 내부 슬롯에 간접적으로 접근할 수 있다. ~~_`__proto__` 는 문을 여는 열쇠와 같다._~~

중요한 역할을 하는 열쇠인 `__proto__` 에 대해서 살펴보자.

**1. 접근자 프로퍼티는 `상속` 을 통해 사용된다.**
접근자 프로퍼티는 객체가 직접 소유하는 것이 아니라, Object.prototype 의 프로퍼티이다.
=> 모든 객체는 상속을 통하여 접근자 프로퍼티를 사용할 수 있다는 것이다.

**2. 접근자 프로퍼티를 통해 프로토 타입에 접근하는 이유는?**
상호 참조에 의해 프로토 타입의 `체인` 이 생성되는 것을 `방지` 하기 위해서이다.

❓`체인` 이 뭐길래 방지를 해야하는 걸까?
💡 객체 들이 서로가 자신의 프로토 타입이 되는 현상 즉, 참조하는 현상이 만들어지는 것을 `프로토 타입 체인` 이라고 부른다.

프로토 타입의 체인이 생성되면 체인 종점이 존재하지 않기 때문에 `무한 루프` 에 빠지게 된다.
그렇기 때문에 ~~_열쇠없이 아무나 출입이 가능하지않게_~~ 즉, 무조건적으로 프로토타입을 교체할 수 없도록 `__proto__` 접근자 프로퍼티를 통해 프로토 타입에 접근하고 교체하도록 구현되어 있다.

**3. 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.❌**

현재 대부분의 브라우저에서 `__proto__` 를 지원하고 있지만 코드 내에서 직접 사용하는 것은 권장하지 않는다.
왜냐하면, 모든 객체가 접근자 프로퍼티를 사용할 수 있는 것이 아니기 때문이다.
이 부분은 나중에 더 자세히 살펴볼 것이기 때문에 간단하게만 살펴보고 넘어가겠다.

프로토 타입의 종점은 `Object.__proto__` 를 상속받을 수 없다.
이렇게 접근자 프로퍼티를 사용할 수 없는 경우가 있기 때문에 코드 내에서 직접 사용하는 것은 권장하지 않는다.

그럼 상속받을 수 없는 경우는 어떻게 프로토 타입을 참조할 수 있을까?

- 프로토타입의 참조를 원할 경우 -> `Object.getPrototypeOf` 메서드 사용 권장
- 프로토타입의 교체를 원할 경우 -> `Object.setPrototypeOf` 메서드 사용 권장

#### 함수 객체만의 prototype 프로퍼티

**| 함수 객체만이 소유하는 프로퍼티는 생성자 함수가 생성할 객체의 프로토타입이다.**

"일반 객체는 프로퍼티를 소유하지 않지만, 함수 객체는 프로퍼티를 소유한다."

엄밀히 말하자면, 일반 함수도 프로퍼티를 소유는 한다. 하지만, 객체를 생성하지 않는 함수의 프로퍼티는 무의미하다.

모든 객체가 가지고 있는 접근자 프로퍼티와 함수 객체만이 가지고 있는 프로퍼티는 결국 `동일한` 프로토 타입을 가리킨다고 볼 수 있지만, 사용하는 주체가 다르다. 이를 정리한 내용은 다음 표와 같다.

| 구분                        | 소유        | 값                | 사용 주체   | 사용 목적                                                     |
| --------------------------- | ----------- | ----------------- | ----------- | ------------------------------------------------------------- |
| `__proto__` 접근자 프로퍼티 | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객제가 자신의 프로토타입에 접근/교체하기 위함                 |
| `prototype` 프로퍼티        | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위함 |

#### 프로토타입의 constructor 프로퍼티와 생성자 함수

모든 프로토타입은 `constructor` 프로퍼티를 갖고, 이 프로퍼티는 `prototype` 프로퍼티로 자신을 참조하고 있는 `생성자 함수` 를 기리킨다. 이러한 연결은 함수 객체가 생성될 때 이루어진다.

### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법에 의한 객체 생성 방식처럼 명시적으로 `new` 연산자로 생성자 함수를 호출하여 객체를 생성하지 않는 방식도 있다.

리터럴 표기법에 의해 생성된 객체도 프로토타입은 존재하다.
하지만 이 경우, 프로토타입의 `constructor` 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 함수라고 확신할 순 없다.

리터럴 표기법에 의해 생성된 객체도 상속을 위한 프로토타입이 필요하다.
그렇기때문에 리터럴 표기법에 의해 생성된 객체도 `가상적인` 생성자 함수를 갖는다.

프로토타입은 생성자 함수와 더불어 생성되며, `prototype`, `constructor` 프로퍼티에 의해 연결되어 있다.
=> **프로토타입과 생성자 함수는 `단독` 으로 존재할 수 없고, 언제나 `쌍(pair)` 으로 함께 존재한다.**

리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입을 정리해보면 다음과 같다.

| 표기법 종류        | 생성자 함수 | 프로토타입         |
| ------------------ | ----------- | ------------------ |
| 객체 리터럴        | Object --   | Object.prototype   |
| 함수 리터럴        | Function    | Function.prototype |
| 배열 리러털        | Array ---   | Array.prototype    |
| 정규 표현식 리터럴 | RegExp      | RegExp.prototype   |

### 프로토타입의 생성 시점

객체는 `리터럴 표기법` 또는 `생성자 함수` 에 의해 생성되므로 결국 모든 객체는 `생성자 함수` 와 연결되어 있다고 봐도 무방하다.

이번 19장의 주제인 `프로토타입` 은 위에서 살펴본 바와같이 프로토타입과 생성자 함수는 쌍으로 함께 존재하므로 결국 생성자 함수가 생성되는 시점에 생성되는 것이다.

여기서 생성자 함수는 사용자가 직접 정의한 `사용자 정의 생성자 함수` 와 자바스크립트가 기본적으로 제공하는 `빌트인 생성자 함수` 로 구분할 수 있다.

각 구분별 프로토타입의 생성시점을 살펴보자.

#### 1. 사용자 정의 생성자 함수의 프로토타입 생성시점

생성자 함수로서 호출할 수 있는 함수 즉, `constructor` 는 함수 정의가 평가되어 객체를 생성하는 시점에 프로토타입도 함께 생성된다.
이 말은 생성자 함수로서 호출할 수 없는 함수 즉, `non-constructor` 는 프로토타입이 생성되지 않는다는 말이다.

프로토타입도 객체이고, 모든 객체는 프로토타입을 가진다. -> 프로토타입도 자기자신의 프로토타입을 가진다는 말이다.

**"프로토타입의 프로토타입은 `Object.prototype` 이다."**

#### 2. 빌트인 생성자 함수의 프로토타입 생성시점

빌트인 생성자 함수(_Object, Number, Function, Array, RegExp 등_) 도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 함께 생성된다.

모든 빌트인 생성자 함수는 `전역 객체` 가 생성되는 시점에 생성되며, 이때 함께 생성된 프로토타입은 빌트인 생성자 함수의 `prototype` 프로퍼티에 연결(바인딩)된다.

=> 정리하자면, 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재하고 있다.
이후 `생성자 함수` 또는 `리터럴 표기법` 으로 객체를 생성하면 프로토타입은 생성된 객체의 `[[Prototype]]` 이라는 내부 슬롯에 할당되고, 프로토타입을 상속받게 된다.

### 객체 생성 방식에 따른 프로토타입 결정

객체를 생성하는 방법에는 다양한 방법이 있는데, 대표적으로 다음과 같은 방법이 있다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

각 방법마다 객채 생성 방식이 다르지만, `추상 연산 (OrdinaryObjectCreate)` 에 의해 생성되는 점은 `공통`적이다.

추상 연산은 무조건 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.
대신 자신이 생성할 객체에 추가할 프로퍼티가 있다면 해당 목록을 `옵션` 으로 전달할 수 있다.

추상 연산에 의해 생성되는 과정을 살펴보면 다음과 같다.

1. 빈 객체 `생성`
2. 객체에 추가할 프로퍼티 목록이 전달된 경우, 프로퍼티를 객체에 `추가`
3. 인수로 전달받은 프로토타입을 자신이 생성한 객체의 `[[Prototype]]` 슬롯에 할당한 후 생성한 객체 `반환`

다양한 객체 생성방법 중 Top3 방법에 따른 프로토타입과 프로퍼티에 대해서 살펴보자.

#### 1. 객체 리터럴 & 2. Object 생성자 함수

두 방법은 공통된 내용이 있어 같이 다뤄보고자 한다.

객체를 생성하고 함수를 호출하면 `추상 연산 (OrdinaryObjectCreate)` 이 호출되며,
추상 연산에 전달되는 프로토타입은 `Object.prototype` 인 점이 공통점이다.

차이점이라고 한다면 프로퍼티 측면인데, `객체 리터럴` 은 `내부` 에 프로퍼티를 추가하지만 `Object 생성자 함수` 는 `빈 객체`를 먼저 생성한 후 프로퍼티를 추가한다는 것이다.

#### 3. 생성자 함수

new 연산자로 호출하여 객체를 생성하는 생성자 함수도 `추상 연산 (OrdinaryObjectCreate)` 을 호출한다는 점에서는 위 두 가지 방법과 동일하다.

단, 추상 연산에 전달되는 프로토타입이 다른데 , 생성자 함수의 `prototype` 프로퍼티에 연결되어있는 객체가 프로토타입이 된다는 점이다.

### 프로토타입 체인

자바스크립트는 객체의 프로퍼티 및 메서드에 접근하고자 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 `[[Prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 `순차적` 으로 검색하는데, 이를 `프로토타입 체인` 이라고 한다.

**`프로토타입 체인` 은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.**

프로토타입 체인의 최상위는 언제나 `Object.prototype` 이다. => `프로토타입 체인의 종점`
즉, 모든 객체는 `Object.prototype` 을 상속 받게되는 것이다.

`Object.prototype` 의 프로토타입인 `[[Prototype]]` 내부 슷롯의 값은 `null` 이며, 종점에서도 프로퍼티를 검색할 수 없는 경우엔 `undefined` 를 반환한다. 이 때, `undefined` 를 반환하는 것이지 에러가 발생하는 것은 아니라는 것을 기억하자!

자바스크립트 엔진은 `프로토타입 체인` 을 따라서 프로퍼티/메서드를 검색한다.
여기서 주목할 점은 프로퍼티가 아닌 `식별자` 는 `스코프 체인` 에서 검색한다는 점이다.
자바스크립트 엔진은 함수의 중첩 관계로 이루어진 스코프 구조에서 `식별자` 를 검색하므로 `스코프 체인` 은 식별자 검색을 위한 매커니즘이라고 볼 수 있다.

얼핏보면 스코프 체인과 프로토타입 체인은 별개인 것처럼 보일 수 있다.
하지만, 프로퍼티를 검색하는 과정을 보면
식별자를 검색한 다음 식별자 객체의 프로토타입 체인에서 메서드를 검색하게 된다.
=> 즉, `스코프 체인` 과 `프로토타입 체인` 은 서로 ~~_으쌰으쌰_~~ 협력하는 관계인 것이다.

### 오버라이딩 & 프로퍼티 섀도잉

- 프로토타입이 소유한 프로퍼티 및 메서드 -> `프로토타입 프로퍼티`
- 인스턴스가 소유한 프로퍼티 -> `인스턴스 프로퍼티`

오버라이딩과 섀도잉 개념을 정의하기 위한 상황을 만들어보자면,
**<상황>**
프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가 -> 프로토타입 체인을 따라 프로토 타입 프로퍼티 를 검색 -> 프로토타입 프로퍼티를 인스턴스 프로퍼티로 추가 (덮어쓰기❌)

**이때, 인스턴스 메서드는 프로토타입 메서드를 오버라이딩 하였고 / 프로토타입 메서드는 프로퍼티 섀도잉 되었다. **

**<개념정의>**

- `오버라이딩` : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식
- `프로퍼티 섀도잉` : 상속관계에 의해 상위 클래스의 프로퍼티가 가려지는 현상

프로퍼티를 생성하는 것과 반대로 삭제하는 경우는 얘기가 조금 달라진다.
하위 객체는 상위 객체의 프로퍼티는 변경 또는 삭제할 수 없다.

**=> 내용을 정리하면, 하위 객체를 통해 상위 객체 프로토타입에 `get` 목적의 접근은 허용되지만, `set` 목적의 접근은 허용되지 않는다.**

### 프로토타입 교체

**| 부모 객체 프로토타입은 동적으로 변경할 수 있다.**

이 말이 무엇이냐하면, 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체될 수 있다는 것이다.

#### 1. 생성자 함수에 의한 교체

생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체를 하게되면 어떤 일이 일어날까?
교체한 객체 리터럴에는 `constructor` 가 없다. 그렇다면 생성자 함수를 검색하면 생성자 함수가 나오는 것이 아니라 `Object` 가 나오게 된다.

이렇듯 프로토타입을 교체하게 되면, `constructor` 프로퍼티와 생성자 함수 사이의 연결이 끊어지는데, 이 경우 `constructor` 프로퍼티를 추가하여 되살릴 수도 있다.

#### 2. 인스턴스에 의한 교체

프로토타입은 인스턴스의 `__proto__` 를 통해서도 접근할 수 있다.
`__proto__` 을 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것과 같다.

인스턴스에 의한 교체인 경우에도 생성자 함수에 의한 교체 내용 중 다음 내용이 동일하게 적용된다.

```
교체한 객체에는 `constructor` 가 없고 검색하면 생성자 함수가 나오는 것이 아니라 `Object` 가 나오게 된다.

그리고 `constructor` 프로퍼티와 생성자 함수 사이의 연결이 끊어지게 된다.
```

이렇게보면 두 가지 교체 방법은 큰 차이가 없어보이지만, 미묘한 차이가 존재한다.

생성자 함수의 `prototype` 프로퍼티가 교체된 프로토타입을 `가리키냐의 여부`가 그 차이이다.

- `생성자 함수` 에 의한 프로토타입 교체 -> 교체된 프로토타입을 가리킴 ⭕️
- `인스턴스` 에 의한 프로토타입 교체 -> 교체된 프로토타입을 가리키지 않음 ❌

프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤 번거로운 일이다.
그렇기때문에 프로토타입은 직접 교체하지 않는 것을 권장하며, 인위적으로 설정을 해야하는 경우에는 뒤에서 살펴볼`직접 상속` 을 이용하는 것이 더 편리하고 안전한 방법이다.

추가적으로 ES6에서 도입된 `클래스` 방법은 더욱 간편하고 직관적인데 해당 내용은 25장에서 등장하니 나중에 살펴보도록 하자!

### instanceof 연산자

`instanceof 연산자` 는 `이항 연산자` 로 `좌변` 에 는 `객체` 를 가리키는 식별자 / `우변` 에는 `생성자 함수` 를 가리키는 식별자가 위치한다.
이 때, 우변의 피연산자가 함수가 아닌 경우 **TypeError** 가 발생하니 주의하자!

```js
객체 instanceof 생성자 함수
```

우변 생성자 함수의 prototype 에 연결된 객체가 좌변 객체의 프로토타입 체인상에 존재하면 `true`, 존재하지 않으면 `false` 로 평가된다.

**instanceof 연산자는 생성자 함수의 prototype에 연결(바인딩)된 객체가 프로토타입 체인상에 존재하는지 여부를 확인하는 역할을 한다.**

instanceof 연산자가 하는 역할을 함수로 살펴보면 다음과 같다.

```js
function isInstanceof(instance, constructor) {
  // 프로토타입 취득
  const prototype = Object.getPrototypeOf(instance);

  // prototype 이 null이면 프로토타입 체인의 종점이다.
  if (prototype === null) return false;

  // 프로토타입이 생성자 함수의 prototype 프로퍼티에 연결된 객체라면 true 반환
  // 그렇지않다면 프로토타입 체인 상의 상위 프로토타입으로 이동하여 확인진행
  return (
    prototype === constructor.prototype || isInstanceof(prototype, constructor)
  );
}

console.log(isInstanceof(me, Person)); // true // me 객체, Person 생성자 함수
console.log(isInstanceof(me, Object)); // true
console.log(isInstanceof(me, Array)); // false
```

앞서 프로토타입 교체에서 살펴본 것처럼 프로토타입이 교체되어 constructor 프로퍼티와 생성자 함수 사이에 연결이 파괴되어도, **생성자 함수의 prototype 프로퍼티와 프로토타입 사이의 연결은 파괴되지 않으므로 instanceof 연산자는 아무런 영향을 받지 않는다**

### 직접 상속

직접 상속에는 크게 두 가지 방법이 있는데 차례대로 살펴보자.
1️⃣ `Object.create` 에 의한 직접 상속
2️⃣ 객체 리터럴 내부의 `__proto__` 에 의한 직접 상속

#### 1. `Object.create` 에 의한 직접 상속

`Object.create` 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성하는데, 이 메서드도 다른 객체 생성방식들과 마찬가지로 `OrdinaryObjectCreate` 를 호출한다.

`Object.create` 메서드의 두 개의 `매개변수`를 받는다.

- 생성할 객체의 프로토타입으로 지정할 `객체`
- 생성할 객체의 프로퍼티 `키` 와 `디스크립터` 객체로 이루어진 `객체` (옵션 -> 생략가능)

```js
/**
* 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환하는 함수이다.
* @param {Object} prototype - 생성할 객체의 프로토타입으로 지정할 객체
* @param {Object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체
* @returns {Object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체
*/
Object.create(prototype[, propertiesObject])
```

그렇다면 `Object.create` 메서드는 어떤 과정에서 직접 상속을 구현하는 걸까?
바로 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성할 때 직접 상속을 구현한다.
이러한 `Object.create` 메서드의 장점으로는 아래 내용이 있다.

- new 연산자 없이 객체 생성이 가능하다.
- 프로토타입을 지정하면서 객체 생성을 할 수 있다.
- 객체 리터럴 방식으로 생성된 객체도 상속받을 수 있다.

#### 2. 객체 리터럴 내부의 `__proto__` 에 의한 직접 상속

앞서 살펴본 `Object.create` 메서드는 장점도 있지만, 두 번째 매개변수로 프로퍼티를 정의하는 일이 번거롭게 느껴진다.
이 때 사용할 방법이 다음과 같이 객체 리터럴 내부에서 `__proto__` 접근자 프로퍼티를 사용하는 것이다.

```js
const myProto = { x: 10 };
// 객체 리터럴에 의한 객체 생성
const obj = {
  y: 20,
  // 객체 직접 상속받음
  // obj -> myProto -> Object.prototype -> null
  __proto__: myProto,
};

console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```

### 정적 프로퍼티 / 메서드

정적 프로퍼티와 메서드는 생성자 함수로 인스턴스를 생성하지 않아도 `참조 및 호출` 을 할 수 있는 것을 말한다.

생성자 함수는 객체이고, 자신의 프로퍼티와 메서드를 가질 수 있다.
-> 생성자 함수객체가 가진 프로퍼티 및 메서드를 `정적 프로퍼티 및 메서드` 라고 한다.

`정적 프로퍼티 및 메서드` 는 생성자 함수가 생성한 `인스턴스` 로 참조 및 호출할 수 없다. ❌

**정리하면, 생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 `객체` 의 프로퍼티 및 메서드에 접근할 수 있다. 하지만, `정적 프로퍼티 및 메서드` 는 `인스턴스` 의 프로토타입 체인에 속한 객체의 프로퍼티 및 메서드가 아니므로 인스턴스로 접근할 수가 없다**

### 프로퍼티 존재 여부 확인

프로퍼티가 존재하는지를 확인하는 방법에는 크게 두 가지가 있는데 하나씩 살펴보자.
1️⃣ `in` 연산자
2️⃣ `Object.prototype.hasOwnProperty` 메서드

#### 1. `in` 연산자

객체 내에 특정 프로퍼티가 존재하는지 여부를 확인하는 연산자이고 형태와 사용방법은 다음과 같다.

```js
/**
 * key: 프로퍼티 키를 나타내는 문자열
 * object: 객체로 평가되는 표현식
 */
key in object;
```

```js
const person = {
  name: "minji",
  address: "sejong",
};

// person 객체에 name 프로퍼티가 존재하는지를 확인
console.log("name" in person); // true
// person 객체에 age 프로퍼티가 존재하는지를 확인
console.log("age" in person); // false
```

단, `in` 연산자는 확인 대상 객체의 프로퍼티뿐만 아니라 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의해야한다.

#### 2. `Object.prototype.hasOwnProperty` 메서드

`Object.prototype.hasOwnProperty` 메서드는 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 `true` 를 반환하고, 상속받은 프로토타입의 프로퍼티 키인 경우에는 `false` 를 반환하므로 `in` 연산자의 단점을 보완한 방법이다.

```js
console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("age")); // false
```

### 프로퍼티 열거

프로퍼티를 열거하는 방법에는 크게 두 가지 방법이 있는데, 하나씩 살펴보자.
1️⃣ `for ... in` 문
2️⃣ `Object.keys/values/entries` 메서드

#### 1. `for ... in` 문

`for ... in` 문은 객체의 모든 프로퍼티를 순회하며 열거할 때 사용한다. (~~_like 반복문_~~)

```js
for (변수선언문 in 객체) {...}
```

```js
const person = {
  name: "minji",
  address: "sejong",
};

// for ... in 문의 변수에 person 객체의 프로퍼티 키가 할당됨
for (const key in person) {
  console.log(key + ":" + person[key]);
}

// name: minji
// address: sejong
```

`for ... in ` 문도 `in` 연산자처럼 상속받은 프로토타입의 프로퍼티까지 열거하지만, 열거할 수 없도록 정의되어있는 상속 프로퍼티는 열거하지 않게 되어있다는 점을 참고하자!

**정리하면, `for ... in` 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 `[[Enumerable]]` 값이 true 인 프로퍼티만을 순회하며 열거한다.**

#### 2. `Object.keys/values/entries` 메서드

방금 살펴본 `for ... in` 문은 상속받은 프로퍼티까지 열거한다는 단점이 있다.
그렇기때문에 객체 자신의 `고유` 프로퍼티만 열거하기 위해서는 `Object.keys/values/entries` 메서드를 사용하는 것을 권장한다.

`Object.keys/values` 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 `배열`로 반환한다.

`Object.entries` 메서드는 객체 자신의 열거 가능한 프로퍼티 `키와 값` 의 `쌍의 배열`을 배열에 담아서 반환한다는 차이점이 있다.

```js
const person = {
  name: "minji",
  address: "sejong",
  __proto__: { gender: female },
};

console.log(Object.keys(person)); // ["name", "address"]
console.log(Object.values(person)); // ["minji", "sejong"]
console.log(Object.entries(person)); // [["name", "minji"], ["address", "sejong"]]
```

### 그래서 "프로토타입" 이 뭔데? 라고한다면,

**| 객체 지향 프로그래밍의 핵심 개념으로 객체들이 속성과 메서드를 공유하고 상속받을 수 있도록 하는 메커니즘이다. 즉, 다른 객체의 속성과 메서드를 물려주는 일종의 템플릿 또는 부모 역할을 하는 것!**

# 5회차 | this

## **22장\_this** <br />

# 이게(_this_) 모에용?

![](https://velog.velcdn.com/images/minji-kim0524/post/d899ec45-dda1-41ba-8417-505fe1d8d6d7/image.png)

"19장.프로토타입" 에서도 살펴봤듯이 객체(`인스턴스`)는 `상태(state)` 를 나타내는 `프로퍼티` 와 `동작` 을 나타내는 `메서드(method)` 를 하나의 단위로 묶은 복합적인 자료구조이다.

여기서 `메서드` 는 자신이 속한 객체의 상태인 `프로퍼티`를 참조하고 변경할 수 있어야 한다.<br />
그렇게하려면 먼저 `메서드`가 속한 객체를 가리키는 `식별자`를 참조할 수 있어야한다.

프로토타입에서 살펴봤듯 프로퍼티를 검색하는 과정은 `식별자`를 검색한 다음! 식별자 객체의 프로토타입 체인에서 `메서드`를 검색하게 된다.

그렇기때문에 `식별자` 참조가 첫 단계이다. <br />
**객체 리터럴 방식**으로 생성한 객체의 경우에는 메서드 `내부`에서 자신이 속한 객체를 가리키는 `식별자`를 `재귀적`으로 참조할 수 있다.

하지만 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지도, 바람직하지도 않다.

그렇다면 **생성자 함수 방식**으로 객체를 생성하는 경우는 어떨까?<br />
생성자 함수 내부에서는 프로퍼티 또는 메서드를 추가하기 위해서는 자신이 `생성할` 인스턴스를 참조할 수 있어야 한다. <br />
그치만 생성 방식을 살펴보면 생성자 함수를 먼저 `정의`한 후 `new` 연산자와 함께 생성자 함수를 호출해야 한다.<br />
=> 즉, 생성자 함수로 인스턴스를 생성하려면 `생성자 함수`가 먼저 `정의`되어서 `존재`해야 한다.

생성자 함수 정의시점에는 인스턴스가 생성되기 전이므로 식별자를 알 수 없다. <br />
그래서 자신이 `속한` 객체 또는 자신이 `생성할` 객체를 가리키는 식별자의 개념으로 등장한 것이 `this` 이다.

**this는 자신이 속하거나 생성할 객체를 가리키는 `자기참조변수` 이며, 자신이 속하거나 생성할 객체의 `프로퍼티` 나 `메서드`를 참조할 수 있다.**

`this` 식별자는 자바스크립트 `엔진`에 의해서 암묵적으로 생성되며, 코드의 어느곳에서든 참조할 수 있지만, `자기참조변수` 이므로 `객체 메서드 내부` 또는 `생성자 함수 내부`에서만 의미가 있다.<br />
그렇기때문에 `strict mode` 가 적용된 `일반 함수` 내부에서의 `this` 는 `undefined` 인데, 일반 함수 내부에서는 `this` 를 사용할 이유가 없기 때문이다.<br />
또한, 함수 내부에서 `지역 변수`처럼 사용할 수 있는데, `this` 가 가리키는 값(바인딩)은 함수 `호출` 방식에 의해 `동적`으로 결정된다. <br />

![](https://velog.velcdn.com/images/minji-kim0524/post/53793e58-6c6e-409f-88a2-ad190cd8b6d6/image.webp)

_알라딘 이야기를 각색하여 적용시켜보면, 지니(`this`)는 알라딘(`호출한 객체`)이 램프를 문질러서 `호출`을 해야만 나온다. <br />
지니는 알라딘을 주인으로 인식하기때문에 알라딘이 호출을 할 땐 나오지만, 주인으로 인식하지 않은 사람이 문지르면 나오지 않을 것이다._

**_[객체 리터럴 방식과 생성자 함수 방식에서의 this 사용법(예제)]_**

```js
// 객체 리터럴 방식
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius; // 여기서 this는 호출한 객체인 circle을 가리킴
  },
};

console.log(circle.getDiameter()); // 10
```

```js
// 생성자 함수 방식
function Circle(radius) {
  this.radius = radius; // 여기서 this는 생성자 함수가 생성할 인스턴스를 가리킴
}

Circle.prototype.getDiameter = function () {
  return 2 * this.radius; // 여기서 this는 생성자 함수가 생성할 인스턴스를 가리킴
};

const circle = new Circle(5);
console.log(circle.getDiameter()); // 10
```

앞서 **this** 에 연결되는 값은 함수가 어떻게 호출됐는지에따라 동적으로 결정된다고 살펴봤다.<br />
근데 바인딩되는 값을 결정하는 `함수 호출 방식` 도 하나가 아니라 다양하다.

다양하 **함수호출방식**에 대해서 알아보자.

### 📋 함수 호출 방식

#### 1. 일반 함수 호출

#### 2. 메서드 호출

#### 3. 생성자 함수 호출

#### 4. 메서드에 의한 간접 호출(Function.prototype.apply/call/bind)

---

### 1. 일반 함수 호출

**| 기본적으로 `this` 에는 `전역 객체`가 바인딩 된다.**

전역함수는 기본이고 `중첩 함수` 도 `일반 함수`로 호출하면 내부의 `this` 에는 `전역 객체` 가 바인딩된다.<br />
`this` 는 `프로퍼티` 나 `메서드` 를 참조하기 위한 `자기참조변수` 이다. <br />
그런데 객체 생성을 하지 않는 `일반 함수` 에서는 의미가 없어지게 된다. <br />
=> 내용을 정리해보면 <br />
"`strict mode`가 아닐 때의 `this`는 _전역객체_ 를 참조하는데, **브라우저** 환경에서의 전역객체는 `window`, **Node.js** 환경에서의 전역객체는 `global`이다. <br />
그런데 `strict mode` 가 적용된 일반 함수 내부에서의 `this` 는 `undefined` 가 바인딩된다."<br />
왜냐하면 누구나 실수를 할 수 있기때문에 의도치않게 전역 객체를 건들이게되면 *전역 오염*이 발생하기 때문이다. <br />

_그런 실수를 막기위해 `strict mode` 일 때의 알라딘 속 지니(`this`) 는 알라딘이 호출했다는 확신이 들지 않으면, "지니없음(`undefined`)" 이라고 알려버리는 것이다._ <br />

_하지만, `strict mode` 가 아닐 때의 지니(`this`)는 알라딘이 호출하지 않더라도 범위를 넓혀서 모두(`전역 객체`)를 호출자로 여기고 "일단 나감(`window`)" 이라고 외치고 램프에서 나오게 된다._

이러한 모드설정여부에 따른 동작차이가 **엄격모드 (`strict mode`)** 가 도입된 배경이기도 하다.

```js
// 객체 생성의 경우
function foo() {
  console.log("foo's this:", this); // window
  function bar() {
    console.log("bar's this:", this); // window
  }
  bar();
}
foo();

//객체 생성을 하지 않는 일반 함수의 경우
function foo() {
  "use strict"; // 엄격모드

  console.log("foo's this:", this); // undefined
  function bar() {
    console.log("bar's this:", this); // undefined
  }
  bar();
}
foo();
```

`콜백 함수` 가 일반 함수로 호출되면 콜백 함수 내부의 `this` 도 전역객체가 바인딩된다.<br />
**이처럼 `일반함수` 로 호출된 `모든` 함수(중첩 함수,콜백 함수 포함) 내부에 있는 `this` 에는 `전역 객체` 가 바인딩된다.**

### 2. 메서드 호출

**| 메서드 내부의 `this` 에는 메서드를 ~~_소유_~~한 객체가 아닌`호출`한 객체가 바인딩된다.**

```js
const person = {
  name: "Kim",
  getName() {
    return this.name;
  },
};

// getName 메서드를 호출한 객체는 person 이다.
console.log(person.getName()); // Kim
```

### 3. 생성자 함수 호출

**| 생성자 함수 내부의 `this` 에는 생성자 함수가 `미래에` 생성할 객체가 바인딩된다.**

```js
function Circle(radius) {
  // 생성자 함수가 미래에 생성할(new 연산자) 객체를 가리킴
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

### 4. 메서드에 의한 간접 호출(_Function.prototype.apply/call/bind_)

**| `apply`, `call`, `bind` 메서드는 `Function.prototype` 의 메서드이기 때문에 모든 함수가 `상속`받아 사용할 수 있다.**

이 메서드는 `this` 로 사용할 `객체`와 `인수 리스트`를 `인수`로 전달받아 함수를 호출한다.

메서드 중 `apply`, `call` 의 사용법은 다음과 같다.

```js
/**
  * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.
  * @param thisArg - this로 사용할 객체
  * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사배열 객체
  * @returns 호출된 함수의 반환값
  */
Function.prototype.apply(thisArg[, argsArray])

/**
  * 주어진 this 바인딩과 ,로 구분된 인수 리스트를 사용하여 함수를 호출한다.
  * @param thisArg - this로 사용할 객체
  * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트
  * @returns 호출된 함수의 반환값
  */
Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])
```

사용법 예제를 보여준 `apply`, `call` 메서드의 본질적인 기능은 `함수 호출`이다. <br />
함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 `this` 에 바인딩하는 것이다.

단, 호출할 함수에 인수를 `전달`하는 방식은 두 메서드가 다르다.

- `apply`: `배열` 로 묶어서 전달
- `call`: `쉼표` 로 구분한 리스트 형식으로 전달

두 메서드가 가진 대표적인 용도는 **_유사 배열 객체에 배열 메서드를 사용할 수 있도록 하기 위함_** 이다. <br />
배열이 아닌 객체에 `Array.prototype.slice` 와같은 배열 메서드를 사용할 수 없는데, 가능하게 해주는 것이 `apply`, `call` 메서드이다.

함수를 호출하는 `apply`, `call` 메서드와달리, `bind` 메서드는 함수를 호출하지 않기때문에 `명시적`으로 호출해야 한다.
대신 첫 번째 `인수`로 `this` 바인딩이 교체된 함수를 새롭게 생성하여 반환한다.

이러한 `bind` 메서드는 메서드의 `this` 와 내부의 `중첩 함수` 또는 `콜백 함수` 의 `this` 가 불일치하는 문제를 해결할 때 유용하게 사용된다.

### 정리하자면,

| 함수 호출 방식                                             | this 바인딩                                                            |
| ---------------------------------------------------------- | ---------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                              |
| 메서드 호출                                                | 메서드를 호출한 객체                                                   |
| 생성자 함수 호출                                           | 생성자 함수가 미래에 생성할 객체                                       |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

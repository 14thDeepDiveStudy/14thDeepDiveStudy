## 스코프(Scope)의 개념

스코프(Scope)는 변수나 함수 같은 식별자가 유효하게 쓰일 수 있는 범위를 의미한다. 코드의 어느 부분에서 특정 변수에 접근할 수 있는지를 결정하는 규칙이라고 할 수 있음. 스코프가 있기 때문에 우리는 서로 다른 스코프에서 같은 이름의 변수를 사용할 수 있다. 마치 컴퓨터에서 서로 다른 폴더에 같은 이름의 파일을 저장할 수 있는 것과 같다. 스코프는 이런 이름 충돌을 막아주는 네임스페이스(namespace) 역할을 한다.

````js
var x = "global x"; // 전역 스코프에 선언된 변수 x
function foo() {
  var x = "local x"; // foo 함수의 지역 스코프에 선언된 변수 x
  console.log(x); // 이 x는 'local x'를 가리킴
}

foo(); // "local x" 출력
console.log(x); // 이 x는 'global x'를 가리킴. "global x" 출력```
````

위 코드처럼 foo 함수 안의 x와 바깥의 x는 이름은 같지만 서로 다른 스코프에 존재하기 때문에 별개의 변수로 취급된다. 자바스크립트 엔진은 현재 실행 중인 코드의 스코프를 기준으로 어떤 변수를 참조할지 결정한다.

## 스코프의 종류

스코프는 크게 전역 스코프와 지역 스코프로 나눌 수 있다.

- 전역 스코프(Global Scope)와 전역 변수
  전역은 코드의 가장 바깥 영역을 말한다. 여기에 변수를 선언하면 전역 변수가 되고, 이 변수는 코드 어디서든—함수 내부를 포함한 모든 곳에서—접근할 수 있다.

- 지역 스코프(Local Scope)와 지역 변수
  지역은 함수 몸체 내부를 의미한다. 함수 내부에 변수를 선언하면 지역 변수가 되고, 이 변수는 해당 함수와 그 함수 안에 중첩된 다른 함수에서만 접근할 수 있다. 함수 밖에서는 참조할 수 없다.

```js
var globalVar = "I am global"; // 전역 변수

function outer() {
  var outerVar = "I am outer"; // outer 함수의 지역 변수

  console.log(globalVar); // "I am global" 출력 (전역 변수 접근 가능)

  function inner() {
    var innerVar = "I am inner"; // inner 함수의 지역 변수
    console.log(outerVar); // "I am outer" 출력 (상위 함수의 지역 변수 접근 가능)
  }

  inner();
  // console.log(innerVar); // ReferenceError 발생 (하위 함수의 지역 변수 접근 불가)
}

outer();
// console.log(outerVar); // ReferenceError 발생 (함수 밖에서 지역 변수 접근 불가)
```

## 스코프 체인 (Scope Chain)

함수가 중첩될 수 있는 것처럼, 스코프도 중첩되어 계층적인 구조를 이룬다. 이렇게 스코프들이 사슬처럼 연결된 것을 스코프 체인이라고 한다. 자바스크립트 엔진은 변수를 찾을 때, 현재 스코프에서부터 시작해서 상위 스코프 방향으로 차례대로 검색해나간다.

1. 현재 스코프에서 변수를 찾는다.

2. 없으면, 바로 위 상위 스코프(자신을 감싸는 외부 함수 스코프)에서 찾는다.

3. 그래도 없으면, 다시 그 위의 상위 스코프로 이동하며 찾는다.

이 과정을 전역 스코프에 도달할 때까지 반복한다.위 예제 코드에서 inner 함수가 outerVar를 찾을 때, 자신의 스코프에 없으므로 상위 스코프인 outer 함수의 스코프로 이동해서 변수를 찾아낸다. 이것이 스코프 체인을 통한 검색 방식이다.

## 함수 레벨 스코프 (Function-Level Scope)

var 키워드는 오직 함수 몸체만을 지역 스코프로 인정한다. 이것을 함수 레벨 스코프라고 한다. if 문, for 문, while 문 같은 코드 블록은 var 키워드에게 별도의 스코프를 만들어주지 못한다. 따라서 함수가 아닌 블록 안에서 var로 선언한 변수는 그냥 전역 변수나 상위 함수의 변수가 되어버린다.

```js
var i = 100; // 전역 변수 i

// for문 안에서 선언한 var i는 새로운 변수가 아니라 전역 변수 i를 덮어쓴다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4 출력
}

// for문이 끝난 후, i의 값은 5가 되어 있다.
console.log(i); // 5 출력
```

## 블록 레벨 스코프 (Block-Level Scope)

var가 가진 함수 레벨 스코프의 단점을 보완하기 위해 ES6부터 let과 const 키워드가 도입되었다. 이들은 함수뿐만 아니라 if, for문 등 모든 코드 블록({...})을 자신만의 지역 스코프로 인정한다. 이것을 블록 레벨 스코프라고 한다.

```js
let i = 100; // 전역 변수 i
// for문 안에서 let으로 선언한 i는 블록 스코프를 가지는 새로운 지역 변수다.
for (let i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4 출력 (블록 안의 지역 변수 i)
}

// for문이 끝난 후, i의 값은 전역 변수 i의 값인 100을 그대로 유지한다.
console.log(i); // 100 출력
```

## 과거의 해결책: 즉시 실행 함수 표현식 (IIFE)

let, const가 없던 시절, 개발자들은 var의 함수 레벨 스코프 특징을 역으로 활용해 독립적인 스코프를 만들었다. 이것이 바로 **즉시 실행 함수 표현식(Immediately Invoked Function Expression, IIFE)**이다. 함수를 정의하자마자 바로 호출해서, 함수 스코프를 마치 블록 스코프처럼 사용하는 패턴이다.

```js
(function () {
  var local = "I am private";
  // 이 안의 변수는 모두 이 함수의 지역 변수가 된다.
  // 바깥 스코프를 오염시키지 않는다.
})();
```

## 렉시컬 스코프 (Lexical Scope)

자바스크립트는 렉시컬 스코프 규칙을 따른다. 이는 함수의 상위 스코프가 함수를 어디서 호출했는지가 아니라, 함수를 어디서 정의했는지에 따라 정적으로 결정된다는 뜻이다.

```js
var x = 1; // 전역 변수

function foo() {
  var x = 10; // foo의 지역 변수
  bar(); // bar 함수를 여기서 '호출'함
}

// bar 함수는 전역 스코프에 '정의'됨
function bar() {
  console.log(x);
}

foo(); // 1 출력(function() {
  var local = "I am private";
  // 이 안의 변수는 모두 이 함수의 지역 변수가 된다.
  // 바깥 스코프를 오염시키지 않는다.
}());
bar(); // 1 출력
```

위 코드에서 foo 함수 안에서 bar()를 호출했지만, bar 함수는 전역에 정의되었다. 따라서 bar 함수의 상위 스코프는 foo의 지역 스코프가 아니라 전역 스코프다. bar 함수가 x를 찾을 때, 자신의 스코프에는 x가 없으므로 상위 스코프인 전역 스코프로 가서 x를 찾는다. 그 결과, foo 내부의 x=10이 아닌 전역 변수 x=1을 출력하게 된다.

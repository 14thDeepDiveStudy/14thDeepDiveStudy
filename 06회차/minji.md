# 6회차 | 스코프

## **13장\_스코프** <br />

# 거기서도 날 참조할 수 있을거라 생각했니?

스코프는 어쩌면 우리가 익히 알고있는 개념이지 않을까.

`변수명`, `함수명`, `클래스명` 등이 어디에 선언되었는지에 따라 어디까지 `참조`되는지 결정된다.

여기서 `어디까지` 가 바로 **스코프(`scope`)** 이다.

아래 예시와함께 `스코프`에 대해 알아가보자.

```js
var x = "squirrel";

function moo() {
  var x = "minji";
  console.log(x); // minji
}

moo();

console.log(x); // squirrel
```

#### 1️⃣ 식별자 결정

가장 바깥 영역과 `moo` 함수 내부에 같은 이름(`x`)의 변수가 선언되었고, 두 군데에서 변수를 참조하는 상황이다. 자바스크립트 엔진은 둘 중 어느 변수를 참조해야할지 결정해야한다. => **_"식별자 결정"_**

즉, 자바스크립트 엔진은 `스코프` 를 기준으로하여 어떤 변수를 참조해야할지 결정하는 것이다. <br />
(_자바스크립트 엔진에게 스코프란 존재는 식별자를 검색할 때 사용하는 규칙이랄까_)

위 예시에서 가장 바깥 영역에 선언된 변수는 어디서든 해당 변수를 참조할 수 있다. <br />
반면 `moo` 함수 내부에 선언된 변수는 함수 내부에서만 참조할 수 있으며, 외부에서는 참조하고싶어도 `moo` 가 방어막을 치고있으므로 참조할 수가 없다.

> **렉시컬 환경**
> | 코드가 어디서실행되고 주변에 어떤 코드가 있는가를 의미함 <br />
> _이를 구현한 것이 `실행 컨텍스트` 이며, 23장에서 자세히 다뤄볼 예정이다._

#### 2️⃣ 식별자란?

**| 어떤 값을 구별하여 식별해 낼 수 있는 `고유한` 이름**

식별자는 값을 구별하는 기준이므로 `유일` 해야하기 때문에 변수이름은 `중복`하여 사용할 수 없다. ❌

`하나의 값 - 하나의 식별자`

하지만 위 예시에서는 동일한 변수명을 사용했는데요?!
→ `스코프` 가 중요한 이유이다.

변수명을 사람 이름으로 비유해본다면,
나는 우리집에서 `유일한` 민지이름을 가졌다. 물론, 다른 형제자매의 이름을 똑같이 지을 수 있지만 그렇게하면 "민지야!" 라고 불렀을 때 누굴 부르는지 알 수 없기때문에(_충돌발생_) 집마다 구성원들의 이름은 다르다.

하지만 다른집에서도 민지이름을 사용해서는 안된다는 것은 아니다. (~~_'민지'라는 이름은 자주 사용되는 변수명느낌_~~)

이렇게 집(가정)이라는 공간이 `스코프` 라고 본다면 그 스코프 안에서만 유일하다면 다른 스코프에서 동일한 이름을 사용하더라도 괜찮다라는 것이다. => **_"스코프는 네임스페이스다!"_**

---

### 그렇다면 스코프엔 어떤 종류가 있을까?

위에서 살펴본 것처럼 `변수`가 선언된 위치에 따라 `스코프`가 결정이 된다.

`전역`에서 선언된 변수는 `전역 스코프`를 갖게되고,<br />
`지역`에서 선언된 변수는 `지역 스코프`를 갖게된다.

`전역`이란 코드의 가장 `바깥` 영역을 의미한다.<br />
변수를 `전역`에 선언하면 `전역 스코프` 를 갖는 `전역 변수`가 되고, 이 `전역 변수`는 어디서든지 참조할 수 있다.

그렇다면 **지역 스코프** 는 어떤 의미일까?

`지역`이란 `함수 몸체 내부` 를 의미힌다.<br />
변수가 `지역`에서 선언되면 해당 변수는 선언된 위치와 그 `하위` 위치인 `중첩 함수` 에서만 참조할 수 있다.

이렇듯 함수는 `전역`에서도 선언할 수 있고, `함수 몸체 내부`에서도 선언할 수 있는데 지역 스코프 `하위`에서 지역 스코프 변수를 참조할 수 있는 것을 확인했다.

```js
// 전역스코프 -------------------------------
var x = 'global x'
var y = 'global y'

function outer(){
 // outer 지역스코프 ------------------------
  var z = 'outer's local z'

  console.log(x) // global x
  console.log(y) // global y
  console.log(z) // outer's local z

  function inner(){
 // inner 지역스코프 ------------------------
    var x = 'inner's local x'

    console.log(x) // inner's local x
    console.log(y) // global y
    console.log(z) // outer's local z
 // inner 지역 스코프------------------------
  }

  inner()
 // outer 지역스코프 ------------------------
}

outer()

console.log(x) // global x
console.log(z) // ReferenceError
// 전역스코프 -------------------------------
```

### 중첩 함수

**| 함수 몸체 내부에서 정의된 함수**

- `함수의 중첩` : 함수 몸체 내부에서 함수가 정의 된 것
- `중첩 함수` : 함수 몸체 내부에서 정의된 함수
- `외부 함수` : 중첩 함수를 포함하는 함수

이렇게 함수가 중첩되면 스코프도 중첩이 된다.<br />
`외부` 함수의 `스코프`는 `중첩` 함수의 `스코프`를 `포함`하는데 이 때, 외부 함수의 스코프를 중첩 함수의 `상위 스코프` 라고 한다.

실제 함수구조가 설명처럼 단순히 중첩함수와 외부함수로만 이루어져 있지는 않다.<br />
모든 스코프는 `계층적 구조` 로 연결되어있으며, 모든 `지역` 스코프에서 상위 스코프를 타고타고 올라가다보면 `최상위` 스코프가 나올텐데 그것이 `전역 스코프` 이다.

**→ 이렇게 계층적으로 연결된 것을 `스코프 체인` 이라고 한다.**

자바스크립트 엔진은 변수를 참조할 때, **스코프 체인**을 통해 하위에서 상위로 이동하며 선언된 변수를 검색한다.

지역 스코프 의미에서 살펴봤듯이 중첩 함수에서는 외부 함수에서 선언된 변수를 참조할 수 있다. <br />
**_즉, `상위` 스코프에서 선언한 변수는 `하위` 스코프에서 참조할 수 있다._**

하지만, 반대의 경우는 유효하지 않다.<br />
자바스크립트 엔진은 `스코프 체인`을 통해 `하위→상위` 로 이동하여 선언된 변수를 검색하지만, `상위→하위` 로 이동하면서 검색하지는 않는다. <br />
**_즉, `하위` 스코프에서 선언한 변수는 `상위` 스코프에서는 참조할 수 없다. ❌_**

`지역`은 `함수` 몸체 내부를 의미하고 여기서 선언된 변수는 `지역 스코프`를 갖는다고 했다. <br />
문장에서도 알 수 있듯이 코드블록이 아닌 `함수`에 의해서만 `지역 스코프`가 생성되는 것이다.

_이 점이 다른 프로그래밍 언어와 자바스크립트의 다른 점 중에 하나인데, 자바나 C언어는 함수에 국한되지않고 모든 코드 블록이 지역 스코프를 만든다._<br />
_→ 이러한 특성을 **블록 레벨 스코프** 라고 한다._

_`var` 로 선언된 변수는 오로지 `함수`의 몸체만을 지역 스코프로 만든다._<br />
_→ 이러한 특성을 **함수 레벨 스코프** 라고 한다._

관련하여 아래 예시를 살펴보자.

```js
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

`var` 키워드는 `함수` 코드블록만을 `지역 스코프`로 인정하기 때문에 `for문` 내에서 선언됐다 하더라도 변수(`i`)는 전역 변수가 되어 `중복` 선언되고 의도치 않는 결과값이 할당되어 나타난다.

이렇듯 `var` 변수는 예측할 수 없는 사고뭉치느낌이라 사용을 지양하고 ES6부터 도입된 _우리에게 친숙한_ `let`, `const` 키워드가 등장한다. <br />
`let`, `const` 키워드는 **블록 레벨 스코프**를 지원한다.<br />
~~_자세한 내용은 15장에서 다뤄보자_~~

---

```js
var x = "squirrel";

function moo() {
  var x = "minji";
  hoo(); // hoo() 호출위치
}

function hoo() {
  // hoo() 정의위치(전역)
  console.log(x);
}

moo(); // squirrel
hoo(); // squirrel
```

위 예시의 실행결과는 두 가지 패턴으로 나눠서 예측할 수 있다.

- 함수를 `어디서` `호출`했는지에 따라 `상위` 스코프를 결정 ➡️ **동적 스코프**
- 함수를 `어디서` `정의`했는지에 따라 `상위` 스코프를 결정 ➡️ **렉시컬(정적) 스코프**

일반적으로 위 두 가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다.

**1️⃣ 동적 스코프**<br />
함수를 정의하는 시점에는 어디서 호출될지 알 수 없기때문에 함수가 `호출`되는 시점에 동적으로 상위 스코프를 결정한다.

**2️⃣ 렉시컬(정적) 스코프**<br />
함수 `정의`가 `평가`되는 시점에 상위 스코프가 정적으로 결정된다.
자바스크립트를 포함한 대부분의 프로그래밍 언어가 해당 방식(`렉시컬 스코프`)을 따른다.

우리가 공부하고 많이 다루는 _자바스크립트_ 는 `렉시컬 스코프`를 따르므로 우리는 함수를 어디서 ~~호출~~ 했는지가 아니라 어디서 `정의` 했는지에 따라 상위 스코프를 결정해야한다.<br />
**→ 함수의 상위 스코프는 언제나 자신이 `정의`된 스코프이다.**

함수선언문 또는 표현식을 통해 함수가 정의되고, 이로인해 생성된 함수 객체는 `정적`으로 상위 스코프를 기억한다.<br />
그래야 함수가 호출될 때마다 상위 스코프를 참조할 수 있기 때문이다. <br />

릭시컬 스코프는 `클로저`와도 관련성이 높은데, 관련 내용은 24장에서 살펴보자!

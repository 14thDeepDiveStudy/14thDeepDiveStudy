## 1. 스코프

### 스코프(Scope) 란?

식별자(변수, 함수명, 클래스명 등)가 다른 코드에 의해 참조될 수 있는 유효 범위.<br>
혹은 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙.

한 스코프 범위 내에서 식별자는 유일해야 한다. 그래야 식별이 가능하기 때문.<br>
이 때, 스코프는 일정 범위 내 식별자를 캡슐화하여<br>
다른 환경에서 동일한 이름의 식별자를 쓸 수 있도록 해 주는 ‘폴더(네임스페이스)’ 역할을 한다.

이 범위가 결정되는 것을 **식별자 결정(Identifier Resolution)** 이라 하며<br>
식별자 결정은 해당 식별자가 선언된 코드의 문맥(Context), 즉 **선언 환경** 에 따라 결정된다.

모든 코드는 해당 코드가 참조 가능한 ‘환경 범위’를 나타내는 **실행 컨텍스트** 를 가진다.<br>
참조 가능한 식별자는 그 안의 **렉시컬 환경(LexicalEnvironment)** 에 저장됨.

따라서, 식별자 결정에 영향을 끼치는 것은 렉시컬 환경이다.

### 렉시컬 환경(LexicalEnvironment)

잠깐 렉시컬 환경에 대해 짚고 넘어가자면<br>
모든 코드는 실행 컨텍스트를 가지며 함수는 호출될 때 자신만의 컨텍스트를 생성한다.

이 때문에 `thisBinding` 등 함수는 동적으로 결정되는 값을 가지기도 하지만,<br>
렉시컬 환경은 일반 코드, 함수 예외 없이 모두 선언된 위치에서 확정된다.

왜냐하면 함수 객체가 만들어질 때(선언될 때)<br>
선언 환경을 참조값으로 저장하는 내부 슬롯 `[[Environment]]` 가 만들어지고<br>
함수 실행 컨텍스트 생성 시엔 이 값이 렉시컬 환경에 전달되기 때문.<br>
(이 때 이례적으로 `new Function` 으로 만든 함수는 태어난 곳이 아닌 전역 렉시컬 환경을 저장하는데 이는 의도적 설계이다.)

즉 렉시컬 환경을 따라가는 스코프 역시 식별자가 선언된 위치에서 결정된다.

이 때문에 아래와 같은 클로저 함수는 호출 위치에 상관 없이<br>
태어난 위치의 렉시컬 환경, 즉 식별자들을 참조 접근할 수 있다.

```tsx
function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();

counter(); // count가 0에서 1이 된다.
```

### 스코프의 종류

식별자의 스코프는 렉시컬 환경, 즉 선언 위치에서 결정된다.<br>
따라서 선언 위치에 따라 스코프 종류를 나눌 수 있다.

실행 컨텍스트(+렉시컬 환경)은 only 전역/함수 로 나눠지므로<br>
스코프 역시 전역과 지역(함수 내부) 스코프로 나뉜다.

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 내부 코드블록    | 지역 스코프 | 지역 변수 |

이 때 함수가 아닌 단순 코드블록(if, for, while 등)은<br>
전역 실행 컨텍스트를 참조하므로 따로 지역 스코프를 만들지 않는다.<br>
또한 전역 스코프에 있는 식별자들은 어디서든 참조 가능하다.

### 스코프 체인(Scope Chain)

렉시컬 환경, 프로토타입과 마찬가지로 스코프도 체이닝된다.

즉, 하위 환경에서 상위 환경을 참조 가능하다.<br>
중첩 함수의 경우 가장 안쪽(하위) 함수가 식별자를 참조할 땐

현재 스코프 → 한 단계 위 지역(함수) 스코프 → 전역 스코프

순으로 검색한 후 가장 먼저 찾은 식별자를 참조한다.

```tsx
let count = 100; // 전역 스코프 변수

function makeCounter() {
  let count = 0; // 상위 지역 스코프 변수

  return function () {
    // 현재 지역 스코프
    return count++;
  };
}

let counter = makeCounter();

counter(); // count가 0에서 1이 된다.
```

즉, 위 예제에서 보면
`makeCounter` 가 반환하는 클로저는 호출 시 `count` 변수(식별자)를 탐색,<br>
스코프 체인을 따라 하위 → 상위로 올라가다가 가장 먼저 마주한 `count = 0` 을 참조해 변경한다.

이렇게 체이닝이 가능한 이유는 앞서 말했던 `[[Environment]]` 에 선언된 환경을 저장하기 때문.

이 슬롯의 참조 환경으로 이동하면 또 다시 그 환경의 `[[Environment]]` 슬롯이 있을 것이고..<br>
`[[Environment]]` 가 전역(`window` / `global`)이 될 때까지 이동(연어)하는 것이다.

이 때문에 스코프 체인 역시 단방향 리스트 형태를 띈다.<br>
하위 → 상위로 참조는 가능하지만 상위 → 하위 참조는 절대 불가능하다.

모든 코드가 전역 스코프를 참조할 수 있지만 전역에선 하위 식별자에 접근 불가한 것도 이 때문.

### 블록 레벨 스코프 vs 함수 레벨 스코프

- **블록 레벨 스코프(Block-level Scope)**<br>
  -> `if` , `for` , `while` , `try..catch` 등에 의해 생성되는 코드 블록을 지역 스코프로 인정하는 것.
- **함수 레벨 스코프(Function-level scope)**<br>
  -> 함수의 코드 블록(함수 몸체)를 지역 스코프로 인정하는 것.

자바스크립트는 따지자면 함수 레벨 스코프를 따르는 언어이다.

실행 컨텍스트 속 렉시컬 환경에 따라 스코프가 결정되고,<br>
실행 컨텍스트는 함수에서만 개별로 생성되기 때문.

따라서 이전까지 JS에서 사용되었던 변수 명명 키워드 `var` 은<br>
함수 코드 블록만을 지역 스코프로 인정했기 때문에<br>
전역에서 선언한 변수 = 코드 블록 안에서 선언한 변수였다.

```tsx
var x = 1;

if (1) {
  var x = 10;
}

console.log(x); // 10
```

하지만 `var` 는 키워드를 붙여 선언하면 이미 선언된 변수라도 재선언이 가능했기 때문에<br>
위처럼 다른 변수를 선언하려다 동일 스코프 내 값을 바꾸는 불상사가 일어날 수 있었다.

이 때문에 ES6부터 자바스크립트는 블록 레벨 스코프를 따르기 시작함.<br>
블록 레벨 스코프를 따르는 변수 선언 키워드 `let` , `const` 가 도입되고<br>
함수 선언 역시 블록 스코프를 따르도록 하게 된 것.

```tsx
let = 1;

if (1) {
  let x = 10;
}

console.log(x); // 1
```

`let` / `const` 로 선언된 식별자 역시 렉시컬 환경에 저장된다.<br>
그런데 어떻게 개인 렉시컬 환경을 가지지 않는 코드블록이 이 값을 별개로 저장하는 것일까?

가볍게 실행 컨텍스트 구조를 보자면 아래와 같은데<br>
이 때 `let` / `const` 변수와 선언된 함수 식별자는<br>
렉시컬 환경 중에서도 **환경 레코드(EnvironmentRecord)** 에 저장된다.

```tsx
ExecutionContext (실행 컨텍스트)
 ├── LexicalEnvironment (렉시컬 환경)
 │    ├── EnvironmentRecord (환경 레코드 -> 블록 단위로 쪼개짐)
 │    └── OuterEnvironmentReference (상위 스코프 참조)
 ├── VariableEnvironment (var용 초기 환경, 호이스팅 처리에 사용)
 └── ThisBinding
```

EnvironmentRecord는 블록 시작 키워드 `{` 을 만나자마자 별도의 레코드를 생성, 바인딩한다.<br>
이후 블록 끝 `}` 을 만나면 해당 레코드는 파기, 이에 저장된 식별자들도 참조 불가능하게 된다.<br>
(참조 불가능하게 된 식별자들은 GC가 처리~)

반대로 환경 레코드가 아닌 VariableEnvironment에 저장되는 `var` 변수는<br>
함수 단위로만 개별 환경을 가져 함수 스코프를 따랐던 것이다.

### 렉시컬 스코프와 클로저

거듭 언급하지만 스코프 범위는 렉시컬 환경을 따른다.<br>
코드가 선언될 땐 태어난 위치의 환경이 `[[Environment]]` 슬롯에 저장되고<br>
실행 컨텍스트 생성 시 이 값이 렉시컬 환경에 바인딩된다.<br>
따라서 선언 당시 이후 절대 바뀌지 않는다. 마치 주민번호 출생지 부분과 같은 것.

이렇게 스코프 범위가 처음 한 번만 결정되는 것을<br>
**렉시컬 스코프(LexicalScope)** 혹은 **정적 스코프(StaticScope)** 라고 한다.<br>
반대로 함수를 호출할 때 호출 위치에 따라 스코프가 결정되는 것을 **동적 스코프(DynamicScope)** 라고 한다.<br>
자바스크립트를 비롯한 대부분 언어들은 렉시컬 스코프를 따름.

스코프는 체이닝이 가능하며 체인 하위에선 상위의 렉시컬 환경을 참조, 즉 식별자 접근이 가능하다.<br>
이 때문에 클로저, 데코레이터와 같은 같은 재밌는 함수를 만들 수 있다.

아래 쓰로틀링 데코레이터는 반환하는 래퍼 함수(하위, 클로저)에서 상위 스코프에 접근할 수 있게 한다.<br>
이 때문에 래퍼로 감싸진 함수가 여러 번 호출되어 함수 렉시컬환경이 초기화되어도<br>
공통적인 상위 스코프 환경(`isTrottled` 등)은 시간 초과 시까지 변화가 없어 호출 제어를 할 수 있는 것.

```tsx
function throttle(f, ms) {
  // 쓰로틀 락 여부 저장
  let isThrottled = false;
  // 마지막 인자, this 저장
  let savedArgs, savedThis;

  function wrapper() {
    // 이번 호출이 '실행 가능한 타이밍인지' 확인
    if (isThrottled) {
      // 인수와 this 상태 저장
      savedArgs = arguments;
      savedThis = this;
      // 호출하지 않고 반환(무시)
      return;
    }

    // 쓰로틀 안 된 상태일때 실행
    f.apply(this, arguments);
    // 쓰로틀 락 온
    isThrottled = true;

    // 단위기간 후 쓰로틀 락 해제되도록 스케쥴링
    setTimeout(function () {
      isThrottled = false;
      // 마지막에 담아놓았던 값이 있으면 호출
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        // 저장 변수 초기화
        savedThis = savedArgs = null;
      }
    }, ms);
  }

  return wrapper;
}

function handleMovePointer() {
  // 이벤트 다수발생 -> 대충 여러 번 실행되는 코드
}

// 반환되는 건 wrapper함수지만 throttle의 환경을 참조할 수 있다.
const throttledHandler = throttle(handleMovePointer, 500);
```

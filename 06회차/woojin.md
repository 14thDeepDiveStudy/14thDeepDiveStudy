# JS DeepDive

## 13.스코프

### 스코프란?

> 식별자가 유효한 범위

모든 식별자(변수명, 함수명, 클래스명 등)는 **자신이 선언된 위치**에 의해 다른 코드가 식별자 쟈신을 참조할 수 있는 유효범위를 가지는데 그것이 **스코프**이다.

```jsx
var scope = "전역이에유";

function local() {
  var scope = "지역이에유";
  console.log(scope);
}

local(); // 지역이에유

console.log(scope); // 전역이에유
```

js엔진은 이름이 같은 두개의 변수 중 어떤 변수를 참조할지 결정하는데 이를 **식별자 결정**이라 한다.
js엔진은 스코프를 통해 어떤 변수를 참조해야되는지 결정하기에 스코프는 **식별자를 검색할떄 사용하는 규칙**이라고 할 수 있다.
이는 js엔진이 코드를 실행할 때 **코드의 문맥**을 고려하는데, 코드가 어디서 실행되며, 주변에 어떤 코드가 있는지에 따라 동일한 코드도 다른 결과를 만든다.

> **코드의 문맥과 환경**
> "코드가 어디서 실행되고, 주변에 어떤 코드가 있는지"를 **렉시컬 환경**이라 한다.
> 즉, 코드의 문맥(context)은 렉시컬 환경으로 이루어지며, 이를 구현한 것이 **실행 컨텍스트**이다.
> 모든 코드는 실행 컨텍스트에서 평가되고 실행한다.

위의 예제를 보면 `scope`라는 변수는 두 번 선언이 됐다.

- 코드의 바깥 영역의 `scope` : 어디서든 참조 가능
- `local` 함수 내부의 `scope` : `local`함수의 **내부**에서만 참조 가능

즉, 두개의 `scope` 변수는 이름은 동일하지만, 스코프가 다른 별개의 변수이다.

스코프라는 개념이 없다면, 이름을 갖는 식별자들은 동일한 이름으로 충돌을 일으킨다.
식별자는 어떤 값을 구별해야 되므로 하나의 값은 유일한 식별자에 연결되어야 한다.

하지만 이름이 중복될 일은 너무나 많기 때문에, 중복된 식별자로 인한 충돌을 방지하기 위해 다른 스코프에 같은 이름의 식별자를 허용할 수 있다.

> 즉, 스코프 === 네임스페이스

변수의 중복 선언

| 구분      | var  | let    | const  |
| --------- | ---- | ------ | ------ |
| 중복 선언 | 가능 | 불가능 | 불가능 |

#### 스코프의 종류

코드는 전역과 지역으로 구분된다

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수의 몸체 내부      | 지역 스코프 | 지역 변수 |

변수는 자신이 **선언된 위치**에 의해 자신의 스코프가 결정된다.

```jsx
// 전역스코프 ------------------------------------------------
var x = "x는 전역이에유";
var y = "y는 전역이에유";

function localOuter() {
  // 지역스코프 ------------------------------------------------
  var z = "z는 외부 지역이에유";

  console.log(x); // 'x는 전역이에유'
  console.log(y); // 'y는 전역이에유'
  console.log(z); // 'z는 외부 지역이에유'

  function localInner() {
    // 지역스코프 ------------------------------------------------
    var x = "x는 내부 지역이에유";

    console.log(x); // 'x는 내부 지역이에유'
    console.log(y); // 'y는 전역이에유'
    console.log(z); // 'z는 외부 지역이에유'
    // ------------------------------------------------
  }

  localInner();
  // ------------------------------------------------
}

localOuter();

console.log(x); // 'x는 전역이에유'
console.log(z); // ReferenceError
// ------------------------------------------------
```

**젼역**

- 코드의 가장 바깥 영역
- 전역 스코프를 만듦
- 변수 선언 시 전역 스코프를 가지는 전역 변수를 생성
- **전역 변수는 어디서든지 참조 가능**

**지역**

- 함수 몸체 내부
- 지역 스코프를 만듦
- 변수 선언 시 지역 스코프를 가지는 지역 변수를 생성
- **지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효**

위 예제에서 가장 상위에 선언된 `x`, `y`는 전역 변수이며, `localOuter` 함수 내부에 선언된 `z`는 지역변수이다.
지역 변수 `z`는 자신과 하위 스코프인 `localInner` 함수 내부에서 참조 가능하지만, 전역에서는 불가능하다.
`localInner` 함수 내부에서 선언된 `x`는 지역변수이며, 자신의 지역 스코프에서만 참조 가능하고 전역이나, `localOuter` 함수에서 참조하려면 참조 에러가 발생한다.

그런데, `x`는 전역변수와 지역변수가 중복된 상황이다. 이때 `localInner`내부에서 `x`변수를 참조하면 전역변수가 아닌 함수 내부에서 선언된 변수를 참조하는데, 이는 js엔진이 **스코프 체인**을 통해 참조할 변수를 검색하기 때문이다.

#### 스코프 체인

우리는 지금까지 프로미스 체인, 프로토타입 체인 등 다양한 ~체인에 대해 배웠는데, 전부 개념은 동일하다.
프로미스나 프로토타입 전부 중첩에 의해 계층적인 구조를 갖는다는 뜻인데, 스코프도 동일하다.

> 스코프 체인 === 스코프가 함수의 중첩에 의해 계층적 구조를 갖는 것

중첩된 함수의 지역 스코프는 외부 함수의 지역 스코프와 계층적 구조를 가지는데, 이때 외부 함수의 스코프를 상위 스코프라고 한다.

위의 예제로 보면 `localInner` > `localOuter` > `전역` 순서로 중첩이 된다.
`localOuter`의 스코프는 `localInner`의 상위 스코프가 되며, `전역`은 `localOuter`의 상위 스코프가 된다.

이렇게 모든 스코프가 계층적 구조로 연결되며, 최상위 스코프는 전역 스코프이다.

> 변수를 참조할 떄 js엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 **상위 스코프 방향으로 이동하며** 선언된 변수를 검색한다.

js엔진은 코드를 실행하기 전에 **렉시컬 환경**을 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 렉시컬 환경(자료 구조)에 키로 등록이 되고, 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 렉시컬환경에서 이뤄진다.

> **렉시컬 환경**
> 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것
> 전역 렉시컬 환경은 코드라 로드되면 바로 생성되며, 함수의 렉시컬 환경은 함수가 호출되면 바로 생성된다.

**상위 스코프에서 유효한 변수는 하위 스코프에서 참조할 수 있지만, 하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없다!**
스코프 체인에 의해 해당 코드의 스코프로부터 상위 스코프로 이동하기 때문!

#### 함수 레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다.

> 즉, 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.

**var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하며 이를 "함수 레벨 스코프"라고 한다.**

```jsx
var fnScope = 1;

if (true) {
  var fnScope = 10;
  //문은 함수가 아니기 때문에 전역변수로 취급되어 중복 선언됨
}

console.log(fnScope); // 10

for (var fnScope = 0; fnScope < 5; fnScope++) {
  console.log(fnScope); // 0 1 2 3 4
  //증감식이 마지막에 실행되서 fnScope에 5를 할당하고 식이 종료됨
}

console.log(fnScope); // 5
```

함수 레벨 스코프가 아닌, 모든 코드 블록(`{}`)을 지역 스코프로 갖는 것은 **블록 레벨 스코프**라고 하며 `let`, `const`로 선언된 변수와 상수는 블록 레벨 스코프를 가진다.

#### 렉시컬 스코프

```jsx
var food = "최애음식";

function pizza() {
  var food = "고구마피자";
  gimbab();
}

function gimbab() {
  console.log(food);
}

pizza(); // ?
gimbab(); // ?
// 함수의 실행 결과는?
```

위 예제의 실행 결과는 `gimbab()`의 상위 스코프가 무엇인지에 따라 결정된다.

1. **함수를 어디서 호출**했는지에 따라 함수의 상위 스코프를 결정
2. **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프를 결정

1번은 동적 스코프(dynamic scope)라고 하며, 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다.
2번은 **렉시컬 스코프(lexical scope), 정적 스코프(static scope)**라고 하며, 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.

js를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

> 즉, 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향을 주지 않으며, 언제나 **자신이 정의된 스코프가 함수의 상위 스코프**이다.

> 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정되며, 생성된 함수 객체는 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문

그래서 위 예제의 console에 뜨는 값은 전부 '최애음식'이다.
~~렉시컬 스코프는 클로저와 깊은 관계가 있으니, 다다음 회차인 클로저를 위해 열심히 개념을 익히자~~

# 7회차 | 실행 컨텍스트

## **23장\_실행 컨텍스트** <br />

# _"나는야 소스코드 관리자!"_

---

먼저 ECMAScript 사양은 소스코드(ECMAScript code)를 다음과 같이 4가지 타입으로 구분하는데, 이 4가지 소스코드는 각자의 상황에 맞는 **실행 컨텍스트**를 생성한다.

| 소스코드 타입             | 설명                                                                                                     |
| ------------------------- | -------------------------------------------------------------------------------------------------------- |
| 전역코드(_global code_)   | 전역에 존재하는 소스코드(전역에 정의된 함수, 클래스 등의 ~~_내부코드_~~는 포함되지 않는다. ❌)           |
| 함수코드(_function code_) | 함수 내부에 존재하는 소스코드(함수 내부에 중첩된 함수, 클래스 등의 ~~_내부코드_~~는 포함되지 않는다. ❌) |
| eval코드(_eval code_)     | 빌트인 전역함수(_eval_)에 인수로 전달되어 실행되는 소스코드                                              |
| 모듈코드(_module code_)   | 모듈 내부에 존재하는 소스코드(모듈 내부의 함수, 클래스 등의 ~~_내부코드_~~는 포함되지 않는다. ❌)        |

그렇다면 소스코드 타입별 `실행 컨텍스트`를 생성하는 과정과 관리하는 내용으로는 뭐가 있을까?

### 소스코드 타입별 실행컨텍스트 생성

#### 1. 전역코드 (_global code_)

- 전역 변수관리를 위해 최상위 스코프인 `전역` 스코프를 생성한다.
- 전역 코드가 `평가`되면 `전역 실행 컨텍스트`가 생성된다.

#### 2. 함수코드 (_function code_)

- `지역`스코프를 생성하고 지역변수, 매개변수, arguments 객체를 관리한다.
- `지역`스코프로 전역 스코프에서 시작되는 `스코프 체인`으로 연결해야하는데, 이를 위해 `함수` 코드가 평가되면 `함수 실행 컨텍스트`가 생성된다.

#### 3. eva코드 (_eval code_)

- `엄격모드(strict mode)`에서 자신만의 독자적인 스코프를 생성한다.
- eval 코드가 평가되면 `eval 실행 컨텍스트`가 생성된다.

#### 4. 모듈코드 (_module code_)

- `모듈별`로 독립적인 모듈 스코프를 생성한다.
- 모듈코드가 평가되면 `모듈 실행 컨텍스트`가 생성된다.

**_즉, 각자의 소스코드가 평가되면 각 실행컨텍스트가 생성되는 것이다._**

소스코드는 실행하기에 앞서 `평가`과정을 거치면서 실행준비를 한다.<br />
위에서도 살펴봤듯이 소스코드 타입별 실행컨텍스트 생성을 하기전에는 `평가` 단계를 거치게된다.

자바스크립트 엔진은 이러한 소스코드를 `소스코드의 평가` 와 `소스코드의 실행`이라는 2가지 과정으로 나누어서 처리한다.

**1. 소스코드 평가**

- 실행 컨텍스트 생성
- 변수, 함수 등의 선언문 먼저 실행
- 생성된 변수, 함수 식별자를 `key`로 실행 컨텍스트 관리 스코프에 등록

**2. 소스코드 실행**

- 선언문 제외한 소스코드 순차적 실행 ⇒ **_런타임 시작!_**
- 평가과정에서 등록해놓은 실행 컨텍스트 관리 스코프에서 소스코드 실행에 필요한 정보(_변수나 함수의 참조_) 검색하여 취득
- 변수 값의 `변경`등 소스코드 실행 결과를 관리 스코프에 등록

```js
var x; // 1. 소스코드 평가 - 변수 선언문 실행 → 관리 스코프에 'x' 등록
x = 5; // 2. 소스코드 실행 - 관리 스코프에 있던 'x' 에 '5'를 할당
```

---

코드가 실행되려면 **스코프**, **식별자**, **코드 실행 순서** 등에 대한 관리가 필요한데, 이 모든 것을 관리하는 것이 바로 `실행 컨텍스트`이다.

### 실행 컨텍스트란?

**| 소스코드를 실행하는 데 필요한 `환경`을 제공하고 코드의 `실행결과`를 실제로 `관리`하는 영역이다.**

조금 더 자세히 살펴보면,
`실행 컨텍스트`는 **식별자**(_변수, 함수, 클래스 등의 이름_)를 등록 및 관리하는 `스코프` 와 코드 `실행 순서 관리`를 구현한 `내부 메커니즘`이다.

**_⇒ 즉, 모든 코드는 실행 컨텍스트를 통해 실행 & 관리된다._**

위에서 설명했듯이 실행 컨텍스트는 크게 `식별자와 스코프` 그리고 `코드 실행 순서`로 구분할 수 있다.<br />
각각을 관리하는 방법이 다른데, `식별자와 스코프`는 실행 컨텍스트의 `렉시컬 환경`으로 관리하고
`코드 실행 순서`는 실행 컨텍스트의 `스택`으로 관리한다.

#### 1. 실행 컨텍스트 스택

자바스크립트 엔진은 소스코드를 평가하여 해당 실행 컨텍스트를 생성하는데, 이 때 생성된 실행 컨텍스트는 `스택` 이라는 자료구조로 관리되고 이를 **실행 컨텍스트 스택** 일명 **콜스택**이라고 부른다.

코드가 실행되면 실행 순서에 따라 `실행 컨텍스트 스택`에 실행 컨텍스트가 `추가(push)` 되기도하고 실행이 완료되면 `제거(pop)`되기도 한다.

![](https://velog.velcdn.com/images/minji-kim0524/post/b938f615-1dcb-4c7e-a91a-4a5fd1e09b0b/image.webp)

**_⇒ 실행 컨텍스트 스택은 코드의 실행 `순서`를 관리한다._**

실행 컨텍스트 스택의 `최상위`에 존재하는 실행 컨텍스트는 언제나 `현재` 실행 중인 코드의 실행 컨텍스트이다. <br />⇒ `실행 컨텍스트 스택의 최상위 실행 컨텍스트는 실행 중인 실행 컨텍스트!`

#### 2. 렉시컬 환경

`식별자`와 식별자에 연결된 값 그리고 상위 `스코프`에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트를 **렉시컬 환경**이라고 부른다.

> **렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체이다**

렉시컬 환경은 다음과같이 두 개의 컴포넌트로 구성되어있다.
![](https://velog.velcdn.com/images/minji-kim0524/post/ebf0a7f7-b80a-4722-b3c4-2060ddd549ff/image.png)

**1️⃣ 환경 레코드**

- 스코프에 포함된 식별자를 등록하고, 식별자에 바인딩된 값을 관리하는 저장소이다.
- 소스코드 타입에 따라 관리하는 내용에 차이가 있다.

**2️⃣ 외부 렉시컬 환경에 대한 참조**

- 이 참조는 `상위 스코프`를 가리키는데, 여기서 `상위 스코프`란 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 위치기준의 상위 코드의 렉시컬 환경을 의미한다.

---

### 실행 컨텍스트의 생성 및 검색과정

그렇다면 실행 컨텍스트는 어떻게 생성되며, 코드 실행결과는 어떻게 관리되는지, 어떻게 실행 컨텍스트를 통해 식별자를 검색하는걸까?

소스코드 타입이 _전역코드_ 인 상황을 예시로 살펴보자.

**1️⃣ 전역객체 생성**
전역코드가 평가되기 전에 전역객체가 먼저 생성되는데, 이 전역객체도 `Object.prototype` 을 상속받는 프로토타입 체인의 일원이다.

**2️⃣ 전역코드 평가**
소스코드가 실행될 준비가 되면 자바스크립트 엔진은 전역코드를 `평가` 한다.<br />
코드 평가는 아래 순서대로 진행되며, 해당 과정을 거쳐 `실행 컨텍스트`와 `렉시컬 환경`이 생성된다.

![](https://velog.velcdn.com/images/minji-kim0524/post/c31ed92f-69d9-440d-9d9b-0700cddd10af/image.png)

각 단계별로 살펴보자.

**1. 전역 실행 컨텍스트 생성**

- 비어있는(_empty_) 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 `스택`에 `푸시`한다.
- 실행 컨텍스트: `실행 중인 실행 컨텍스트`

**2. 전역 렉시컬 환경 생성**

- 전역 렉시컬 환경 생성 후 전역 실행 컨텍스트에 바인딩한다.

  **2-1. 전역 환경 레코드 생성**<br />

  - 전역 변수를 관리하는 `전역 스코프`, 전역 객체의 `빌트인 전역 프로퍼티`, `빌트인 전역 함수`, `표준 빌트인 객체` 를 제공한다.
  - `객체 환경 레코드` 와 `선언적 환경 레코드`로 구성되어 있다.
  - ES6 이전에는 전역 객체가 전역 환경 레코드 역할을 하였으나, 그 시절은 `var`를 쓰던 시절이다. 하지만, 지금은 `let`, `const` 를 쓰는 시절이기때문에 전역 변수는 전역 객체의 프로퍼티가 되는 것이 아닌 `블록`내에 존재하게 된다.
    이것이 `객체 환경 레코드`와 `선언적 환경 레코드`가 구분되고 등장하게된 배경이다. - `객체 환경 레코드`: var키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체 관리
  - `선언적 환경 레코드`: let, const키워드로 선언한 전역 변수 관리

```js
var x = 1 // 선언단계, 초기화단계 동시 진행됨
const y = 2

function foo(a) {
  ...
}
```

<img src="https://velog.velcdn.com/images/minji-kim0524/post/4549f505-ce48-4cd2-8956-9fa106ee8968/image.png" width=800px>

<img src="https://velog.velcdn.com/images/minji-kim0524/post/8b56eb01-388b-438b-8d53-98d3bc0344c4/image.png" width=800px />

**2-2. this 바인딩** <br /> - 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩 된다. <br /> - 일반적으로 전역코드에서는 내부슬롯에 전역 객체가 바인딩된다. <br /> - 전역 코드에서 this 참조시 내부 슬롯에 바인딩되어 있는 `객체`가 반환된다. <br /> - 전역 환경 레코드의 두 가지 컴포넌트에는 this 바인딩이 없으며, 전역 환경 레코드와 함수 환경 레코드에만 존재한다.

**2-3. 외부 렉시컬 환경에 대한 참조 결정** <br /> - 현재 평가 중인 소스코드를 포함한 상위 스코프를 의미한다. <br /> - 현재 평가 중인 코드가 `전역 코드`인 경우에는 상위 스코프가 없으므로 `외부 렉시컬 환경에 대한 참조`에 `null` 이 할당된다. <br />⇒ **_전역 렉시컬 환경이 스코프 체인의 종점에 존재한다는 것을 의미한다._**

**3️⃣ 전역코드 실행**<br />
변수 할당문, 함수 호출문 실행 전에 식별자여부를 확인하여야 한다.<br />
선언되지 않은 식별자는 `참조`할 수 없고, 그럼 `할당`이나 `호출`도 할 수 없기때문이다. 추가적으로 참고할 사항은 식별자는 ~~_13장에서 다뤘던_~~ `스코프`가 다르면 같은 이름을 가질 수 있다.<br />
동일한 이름의 식별자가 다른 스코프에 존재할 수도 있다는 것이다.<br />
그래서 `어떤 스코프`의 식별자를 참조할 것인지 결정을 해야하는데, 이것을 **식별자 결정**이라고 한다.

**식별자 결정**을 하기위해서는 `검색`을 먼저해야하는데 이 때 실행 중인 실행 컨텍스트(_최상위_)에서 검색을 시작한다.

- 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색결과가 없다고 한다면 `상위 스코프`로 이동하여 검색을 진행한다. ⇒ **_스코프 체인의 동작원리_**
- 상위 스코프에서도 검색을 하지 못한 경우에는 `참조 에러(Reference Error)`가 발생한다.

---

### 예시코드와 함께 코드 평가과정정리

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }

  bar(10);
}

foo(20); // foo함수 호출 시-작!
```

위 예시를 기준(_foo함수 호출 시-작!_)으로 전체적인 흐름을 살펴보면 다음과 같다.

![](https://velog.velcdn.com/images/minji-kim0524/post/d524754a-9722-448c-9787-18350464b3ca/image.png)

- 먼저 전역 코드의 실행을 멈추고 `foo 함수` 내부 코드로 포커스가 이동한다.
- `foo 함수` 내부 코드의 평가가 아래의 순서로 시작된다.
  - 함수 실행 컨텍스트 생성
  - 함수 렉시컬 환경 생성
    - 함수 환경 레코드 생성
    - this 바인딩
    - 외부 렉시컬 환경에 대한 참조 결정
- 런타임시작과 함께`foo 함수` 코드가 순차적으로 실행되어, 식별작 결정을 위한 검색과정을 거쳐 값이 `할당`되고 `bar 함수`가 실행된다. 다음은 `foo 함수` 코드가 실행된 모습이다.

![](https://velog.velcdn.com/images/minji-kim0524/post/b301051e-678f-4fe4-b85c-1ec11b5b532f/image.png)

- 이제 `foo 함수` 내부에 위치하여 호출된 `bar 함수` 내부 코드의 평가가 시작된다. `foo 함수` 에서 진행했던 평가과정과 동일하게 `bar 함수` 코드에 대한 평가도 진행되면서 `실행 컨텍스트` 와 `렉시컬 환경`이 생성된다.
- `foo` 의 과정과 동일하게 런타임이 시작되면 `bar 함수` 소스코드가 순차적으로 실행된다. **매개변수**에 **인수**가 할당되고 **변수할당문**이 실행되면서 지역 변수에 값이 **할당**된다.
- 마지막으로 `bar 함수`안에있던 `console.log(a+b+x+y+z)` 가 실행되어 최종 값이 콘솔창에 찍힌다. 아래 그림은 `bar 함수` 코드가 실행된 모습이다.

![](https://velog.velcdn.com/images/minji-kim0524/post/1fdf7dbe-3994-461c-b76b-66d9b78a7b66/image.png)

> **_🚨여기서 `console.log(a+b+x+y+z)` 의 결과와 각 변수에 어떤 값들이 할당됐을까?_**

```js
var x = 1; // ❌ 더 가까운 렉시컬 환경에서 값을 이미 발견하여 할당완료
const y = 2; // ❌ 더 가까운 렉시컬 환경에서 값을 이미 발견하여 할당완료

function foo(a) {
  var x = 3; // ✅ x 발견!
  const y = 4; // ✅ y 발견!

  function bar(b) {
    const z = 5; // ✅ z 발견!
    console.log(a + b + x + y + z); // 현재 실행중인 컨텍스트의 렉시컬 환경에서부터 검색시작
  }
  bar(10); // ✅ b 발견!
}
foo(20); // ✅ a 발견!
```

- `console.log` 가 호출되고나면 더 이상 실행할 코드가 없으므로 `bar 함수` 코드의 실행은 `종료`된다. 이렇게 **종료(완료)** 되었을때가 글의 첫 부분 **1. 실행 컨텍스트 스택**에서 말했던 것처럼 스택에서 `제거(pop)` 된다.

> **_✋🏻여기서 잠깐! 스택에서 함수실행 컨텍스트가 제거되면 렉시컬 환경도 바로 사라질까?_** <br />
> **"No!"** <br />
> 렉시컬 환경은 실행 컨텍스트에 의해 참조만 될뿐 `독립적`인 객체이다. <br />
> `객체`를 포함하여 모든 값은 나를 참조해주는 곳이 없을 때가 되어서야 `가비지 컬렉터`에 의해 메모리공간 확보가 해제되면서 ~~_스르륵 먼지처럼_~~ 사라진다.

- `bar 함수`가 종료되어 스택에서 사라지면 다음 순서는 `foo 함수`가 된다. `foo 함수`에서도 실행할 코드가 없으므로 종료되고, 스택에서 `제거(pop)` 된다.
- `foo 함수`까지 종료되고나면 더 이상 실행할 코드가 남아있지 않으므로 `전역 코드`의 실행이 종료되고 `실행 컨텍스트`도 스택에서 `pop! pop!` 되어 아무것도 남아있지 않으며 끝난다. **_ The End _**

---

### 블록 레벨 스코프

렉시컬 환경생성 내용에서 살짝 살펴봤듯이 `var` 키워드로 선언한 변수는 오로지 함수의 `코드 블록`만 지역 스코프로 인정한다. ~~_이 부분 [15장. let, const 키워드와 블록 레벨 스코프]에서 자세하게 살펴볼 예정이다_~~

그에비해 `let`, `const`키워드로 선언한 변수는 `모든` 코드 블록(_함수, if문, for문, while문, try/catch문 등_)을 지역 스코프로 인정하는데 이를 **"블록 레벨 스코프"** 라고 한다.

코드 블록 실행이 종료되면 코드 블록이 실행되기 이전의 렉시컬 환경으로 되돌아간다.

이 부분이 개념관련해서는 24장에서 다루는 *클로저*와 연관되어 24장에서 자세하게 살펴보자!

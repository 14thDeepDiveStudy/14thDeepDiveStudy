## 실행 컨텍스트가 뭔가여?

- 자바스크립트 동작 원리의 뼈대를 이해하는 열쇠. 호이스팅, 스코프, 클로저, `this`, 비동기 프로그래밍 모두 여기서 출발합니다.

  - 코드가 실행되기 위해 필요한 환경을 제공하고, 실행 결과를 관리하는 일종의 “실행 정보 저장소”.

- 저자가 서론에서도 언급했다시피, 실행 컨텍스트를 이해하게 된다면
  자바스크립트의 난제? (개인의 생각) 혹은 뉴비 분쇄기 라고도 할 수 있는 것들이 조금은 친숙해질 것입니다.

> **예를 들어...**
>
> 1. 호이스팅이 발생하는 이유
> 2. 클로저(Closure)의 동작 방식
> 3. 비동기 처리의 동작 방식

---

### || 개인적인 학습 목표 ||

- 실행 컨텍스트를 모른다면 설명하기 어려운 현상(호이스팅, `this` 바인딩, 클로저)을 떠올려 본 뒤, 학습을 마치고 실행 컨텍스트를 활용해 다시 설명해봅니다.

---

일단 저는 이 **실행 컨텍스트**라는 단어가 크게 낯설지 않았어요. 왜냐하면 ...

![1회차 실행 컨텍스트 언급](https://velog.velcdn.com/images/smang66/post/dac2147a-5bdb-40a1-8a6f-64a5704efea7/image.png)

---

저희 스터디의 첫 번째 주제이자 제 영광스러운 첫 발표에 바로 이 **실행 컨텍스트** 라는 단어를 언급했기 때문이죠.

그런데, 우리가 오늘 학습할 "**실행 컨텍스트**(23장)"랑 예전에 언급한
"**실행 컨텍스트**(42장, 비동기 프로그래밍)가 같은 뜻을 의미하고 있을까요?

---

### ✅확인해봅시다.

- 42장의 문맥 속 "실행 컨텍스트"는 **콜 스택의 동작 원리** 속에서 실행 컨텍스트가 생성·`push`·`pop`되는 과정을 설명하는 것입니다.

> 즉, 콜 스택(Call Stack)에서 실행 컨텍스트가 쌓이고 사라지는 **흐름**에 초점을 맞춘 것이지요..

- 지금 학습할 실행 컨텍스트는 실행 컨텍스트의 **내부 구조와 본질**을 이야기하고 있습니다.

> 즉. 실행 컨텍스트 내부에 **어떤 정보가 저장되는지**에 초점을 맞춘 것입니다.

---

좋습니다. 이제 우리는 실행 컨텍스트의 내부 구조와 본질을 학습해볼 것입니다.

---

## 1️⃣ 23.1 소스코드의 타입

> 실행 컨텍스트는 소스코드의 타입에 따라 다르게 생성됩니다.
> 이 구분이 없다면 엔진은 어떤 환경을 만들어야 할지 알 수 없습니다.
> (실행 컨텍스트의 생성 과정, 관리 내용이 각각 다르기 때문.)

### 1. 전역 코드

- 전역 실행 컨텍스트 생성. 파일 전체가 실행될 때, 가장 먼저 전역 실행 컨텍스트가 생성된다.

```js
// 전역 코드
const message = "Hello, World!";
console.log(message); // "Hello, World!"
```

⚠️ **전역에 정의된** 함수, 클래스 등의 **!내부코드!**는 포함되지 않는다.

---

### 2. 함수 코드

- 함수를 호출하면 함수 실행 컨텍스트가 새로 만들어진다.

```js
function greet(name) {
  const message = `Hello, ${name}`;
  console.log(message);
}

greet("남일쒸"); // 함수 실행 시 함수 실행 컨텍스트 생성
```

> 💡 `greet("남일쒸")`를 호출하는 순간 새로운 함수 실행 컨텍스트가 콜 스택에 쌓였다가, 실행이 끝나면 팝(pop)됩니다. (없어진다는 뜻)

⚠️ **함수 내부에 중첩된** 함수, 클래스 등의 **!내부코드!**는 포함되지 않는다.

---

### 3. eval 코드

- `eval` 안의 코드는 독립된 `eval` 실행 컨텍스트에서 실행된다.

```js
eval("const num = 100; console.log('Eval:', num);");
```

⚠️ 실무에서는 보안/성능 문제 때문에 잘 쓰지 않는다고 하네요

---

### 4. 모듈 코드

- ES 모듈(`type="module"`)을 사용하면 모듈 실행 컨텍스트가 생성된다.

```js
// math.js (모듈 파일)
export const add = (a, b) => a + b;

// main.js
import { add } from "./math.js";
console.log(add(2, 3)); // 5
```

> 💡 모듈은 자동으로 `strict mode`가 적용되고, 모듈별로 독립적인 실행 컨텍스트가 생긴다.

⚠️ **모듈 내부의** 함수, 클래스 등의 **!내부코드!**는 포함되지 않는다.

=> 각 소스코드 마다 "**특정 범위**의 함수, 클래스등의 내부코드가 포함되지 않는다"가 핵심입니다.

---

## 2️⃣ 23.2 소스코드의 평가와 실행

- 모든 소스코드가 "띡"하고 바로 실행되는 것은 아닙니다.
  코드를 실행하기 위해 일종의 오디션(평가) 과정을 거쳐야합니다.

👉 자바스크립트의 엔진은 소스코드를 "평가"와 "실행"의 과정으로 나누어 처리한다는 것이지요.

> 조금만 더 풀어서 이야기 해보자면
> 자바스크립트 엔진이 코드를 실행할 때는 곧장 **위에서부터 실행하지 않고** 먼저 **"평가"** 라는 준비 과정을 거쳐서 실행할 준비를 한다는 뜻입니다.

---

### 1. 평가 단계

1. [실행 컨텍스트] 를 생성한다.
2. 변수를 저장할 [칸], 함수를 저장할 [칸]을 준비한다.
3. 선언문만 먼저 처리한다.

```js
let a = 1;

function namilc() {
  console.log("trash");
}
// 선언문을 처리하는 과정에서 a라는 변수와
// namilc라는 함수가 있다는 사실을 등록해야 한다.
```

4. 이 등록 정보를 스코프(렉시컬 환경의 환경 레코드) 안에 등록한다.
   즉 "**어떤 이름**(남일쒸)이 **어디서**(집) 사용 가능한가"를 미리 기록하는 작업.

---

### 2. 실행 단계

1. 런타임 시작. (선언문 제외 소스코드가 차례로 동작하기 시작)

2. 실행할 때 필요한 값(`a`라는 변수를 찾거나 `namilc()`라는 함수를 실행하는 것)은 평가 단계에서 만든 실행 컨텍스트와 스코프에서 가져온다.

3. 실행 결과, 변수 값이 바뀌거나 새로운 값이 만들어지면 그 정보가 다시 실행 컨텍스트에 저장된다.

![그림 23-2 소스코드의 평가와 실행 과정](https://velog.velcdn.com/images/smang66/post/e1b378fd-6670-4576-b059-441e0f0d0b43/image.png)

> 알기 쉽게...
> => **평가 단계** 는 요리 시작 전에 재료를 다 꺼내놓고 칼, 냄비, 도마 같은 도구를 세팅.
> => **실행 단계**는 재료를 필요하면 **칼**로 썰고, 필요하면 **냄비**에 담고, **간**이 안맞으면 조미료를 넣고 등의 과정.

---

### 3. 예시 코드

```js
var x;
x = 1;
```

**평가 단계**:

1. 선언문인 `var = x`만 실행.
2. 변수 식별자 `x`는 실행 컨텍스트에 `undefined`로 등록. (`var`라서.)

**실행 단계**:

1. `var = x`는 이미 오디션 심사 끝.
2. 할당문인 `x = 1` 실행
3. 그 전에 선언된 변수가 맞는지 스코프에서 확인함.
4. 참이면 `x`에 `1` 할당.

---

### 4. 조금만 더!!! (심화 단계)

"평가"와 "실행"의 분리를 이해하면 **"왜 선언이 호이스팅되는가?"**,
**"변수를 선언하기 전에 참조하면 왜 `ReferenceError`(참조 오류)가 나는가?"** 같은 질문에도 답을 할 수 있습니다.

> 💡 호이스팅의 근본 원인은 **평가** 단계에서 **선언**을 먼저 처리하기 때문입니다.

```js
console.log(x); // ReferenceError
let x = 10;
```

엔진은 이 코드를 만나면 먼저 "평가" 단계를 거칩니다.
이때, `let x`라는 변수가 있다는 사실만 "재료 목록"에 기록해 두고, 실제 값은 아직 안 담겨있죠.

왜냐하면 **TDZ(Temporal Dead Zone, 일시적 사각지대)** 라는 구간에 놓여 있어서, 선언문이 실행되기 전에는 접근할 수 없는 상태입니다.

> 💡 TDZ는 `let`과 `const`에만 한정되는 구간입니다.

그래서 실행 단계에서 `console.log(x)`를 실행하려고 보니,
"x라는 이름은 분명히 목록에 있지만 아직 쓸 수 없는 상태"인 것입니다.
그래서 참조 오류인 `ReferenceError`가 발생하게 되는 것이에요.

> 아까의 요리 과정으로 또 비유를 해보자면,
>
> **평가 단계** 에서 "식칼이 있다"는 사실만 알게 되었다. 하지만 이 식칼은 아직 나의 손에 쥐어져 있지 않다.
>
> **실행 단계** 에서 당근을 썰기 위해 식칼을 집어 들려고 했는데, 식칼을 들 수가 없는 상태 (식칼이 봉인되어 있음 ~~엑스칼리버?~~)

`var`는 조금 달라요. 근데 더 설명하기 귀찮아요 ㅎㅎ.. 문제아까지 다룰 에너지가 없습니다.

> 이 내용에 흥미가 생겼다면, 만약 TDZ가 없었을 때 어떤 문제가 생길지 상상해보세요. (저는 모름)

---

## 3️⃣ 23.3 실행 컨텍스트의 역할

- 자바스크립트 엔진이 전역 코드와 함수 코드로 구성된 이 예제를 어떻게 평가하고 실행할까? 배운 것을 떠올려봅시다.

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

### 1. 전역 코드 평가

- 전역 컨텍스트가 생성됨. (소스코드 타입의 1번째 레슨, 전역 코드가 생성)
- 맨 위에 있는 `const x`, `const y` 선언이 스코프에 등록. (아직 할당은 안 됨, TDZ = 실행되기 전에 접근X 상태)
- `function foo(a)` 가 통째로 스코프에 등록됨. (선언문이기 때문)

### 2. 전역 코드 실행

- `x = 1`, `y = 2`가 실제 값으로 초기화. (스코프에 등록된 `const` 참조)
- `foo(100)` 호출 → 새로운 실행 컨텍스트 (소스코드의 2번째 레슨, 함수 코드)가 콜 스택(Call Stack)에 push.

### 3. 함수 코드 평가

함수 내부의 문들을 실행하기 전 과정. **매개변수**와 **지역 변수 선언문** 먼저 실행.
=> 생성된 매개변수와 지역변수는 또 지역 스코프에 등록됨

- 매개변수 `a`가 스코프에 등록되고 100이 바인딩됨.
- 지역 변수 `x = 10`, `y = 20` 선언 등록 (TDZ → 실행 안됐기 때문에 아직 값이 없음).

### 4. 함수 코드 실행

- `x = 10`, `y = 20` 값 할당. (스코프가 알고 있는 정보)
- `console.log(a + x + y)` 실행 → 100 + 10 + 20 = 130 출력.
- `foo` 실행 종료 → 실행 컨텍스트 pop(제거, 내보냄).

> 흐름만 요약한다면?
> 👉 전역 코드 평가 과정에서 선언문만 실행, 스코프에 등록
> 👉 실행 과정에서 스코프에 **등록된 값으로 초기화** 및 **변화된 값** 반영,
> 그 외의 문(🚪X) 처리 과정에서 함수 호출에 의해 실행 순서 변경 시 함수 코드의 실행 컨텍스트 생성. 이 때 Call Stack 입장.
> 👉 또 선언문만 먼저 실행, 지역 스코프에 등록.
> 👉 또 스코프에 등록된 값으로 초기화 및 값 변화 반영. 이젠 함수 호출이 끝났으니 Call Stack에서 나가세요.

---

### 조금만 더!!!

실행 컨텍스트는 크게 세 가지의 정보 뭉탱이를 관리한다.

### 1. Variable Environment (변수 환경)

- 선언된 변수, 함수 선언을 기록해 두는 저장소.

💡 `var`, `function` 선언 등이 여기에 들어간다.

### 2. Lexical Environment (렉시컬 환경)

- 변수 환경 + 외부 렉시컬 환경 참조
  쉽게 말하면 "내가 가진 변수 + 바깥 스코프에서 참조할 수 있는 변수"를 한꺼번에 기억하는 구조이다.

💡 `let`, `const`, 함수 스코프 체인 등이 여기에 걸린다.

- 어떤 변수를 찾을 때 현재 스코프 → 바깥 스코프 → … → 전역 스코프 순으로 탐색하는 것도 Lexical Environment에 기록된 참조 덕분.

> 💡 함수가 선언될 당시의 위치에 따라 외부 환경이 연결되므로
> "렉시컬(정적) 스코프"라는 이름이 붙었다.
>
> **"함수가 선언될 때 결정된다"** <= 잘 알아두세요 클로저 개념의 기반이자 여러분들이 다음 주에 공부할 내용이에요^^

### 3. This 바인딩

- 현재 실행 중인 코드 블록에서 `this`가 무엇을 참조해야 하는지 결정한다.
  => 왜 이게 중요한지는 저희가 저번에 학습했답니다!

1. 전역 컨텍스트에서는 보통 `window`나 `global`.

2. 함수 내부에서는 호출 방식에 따라 달라진다.
   (단순 호출 vs 메서드 호출 vs `new` 생성자 호출).

> 💡 `obj.method()` → `this`는 obj.
>
> 💡 `function()` → `this`는 기본적으로 전역 객체
> (strict 모드에선 `undefined`).
>
> 💡 `new Function()` → `this`는 새로 생성된 인스턴스.
>
> => 실행 순간의 호출 방식에 따라 동적으로 결정된다.

---

## 4️⃣ 23.4 실행 컨텍스트 스택

### 핵심 포인트

- 실행 컨텍스트는 스택 구조(LIFO)로 관리됨.
- 전역 컨텍스트가 맨 밑에서 프로그램 전체를 지탱.
- 함수 호출 시 새로운 실행 컨텍스트 `push` → 종료되면 `pop`

> 1회차 발표 서론 때 실행 컨텍스트가 뭐시기.. 말이 어렵다고 제가 쉽게 풀어드린 적이 있습니다. 예 맞아요. **실행 컨텍스트 스택 = 콜 스택** 입니다.
>
> 간단하게 요약하고 넘어가겠습니다.

- 전역 코드, 함수 코드가 실행될 때마다 새로운 실행 컨텍스트가 만들어져 스택에 `push`된다.
- 실행이 끝나면 해당 컨텍스트는 스택에서 `pop`되어 제거된다.
- 항상 스택의 맨 위(top)에 있는 실행 컨텍스트가 “지금 실행 중인 코드”를 의미한다.

### 예시 코드

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

### 전역 코드 실행 시

전역 실행 컨텍스트 생성 → 스택에 push.

`foo()` 호출 시: `foo` 실행 컨텍스트 생성 → push.

`bar()` 호출 시: `bar` 실행 컨텍스트 생성 → push.

`bar` 실행 종료: `bar` 실행 컨텍스트 pop.

`foo` 실행 종료: `foo` 실행 컨텍스트 pop.

전역 실행 종료: 전역 실행 컨텍스트 pop → 스택이 비게 됨.

> 이 구조 덕분에 자바스크립트 엔진은 현재 어떤 코드가 실행 중인지, 실행이 끝나면 어디로 돌아가야 하는지를 잊지 않고 관리할 수 있다.
>
> => 일종의 **실행 순서 기록부**인 셈이다.

### 더 알아보면 좋은 것.

- 재귀 호출 시 스택 오버플로우가 발생하는 이유를 실행 컨텍스트 스택 관점에서 정리해보세요. (일단 난 안함)

---

## 5️⃣ 23.5 렉시컬 환경(Lexical Environment)

### 1. 렉시컬 환경이란?

- 실행 컨텍스트 내부의 "저장소". **식별자(변수, 함수 선언 등)**와 식별자에 바인딩된 값이 어떻게 연결되어 있는지를 기록한다.

---

실행 컨텍스트 스택 (콜 스택)과의 차이점...

> 실행 컨텍스트 스택👉 코드의 실행 순서를 관리
>
> 렉시컬 환경 👉 스코프와 식별자를 관리

![렉시컬 환경 설명.](https://velog.velcdn.com/images/smang66/post/d8c9209b-0ba6-4f42-8189-d1371b49c7c6/image.png)

### 2. 내부 구조

### 환경 레코드 (Environment Record)

> 현재 무대의 대본

- 현재 스코프 안에 선언된 식별자와 값을 보관하는 테이블.
  `var`, `let`, `const`, 함수 선언문 등이 들어간다.

종류에 따라

Object Environment Record(전역 객체 바인딩),
Declarative Environment Record(`let`/`const`, 함수 매개변수 등)로 나뉜다.

### 외부 렉시컬 환경 참조 (Outer Lexical Environment Reference)

> 상위 무대와 연결선

- 현재 스코프에 없는 식별자를 찾을 때 참조하는 상위 환경.
  이 연결이 체인처럼 이어져서 우리가 말하는 "스코프 체인"이 된다.

> 렉시컬 환경은 아까도 말했지만 식별자와 스코프를 기록.

### 구성

- 환경 레코드 → 변수, 함수 식별자 저장.

- 외부 렉시컬 참조 → 상위 스코프 참조.

### 예제

```js
const x = 1;

function foo() {
  const y = 2;
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo(); // 6
```

#### Global Lexical Environment

- `x`, `foo`가 기록됨.

#### `foo` Lexical Environment

- `y`, `bar`가 기록됨.

- 외부 참조 → `Global`

#### `bar` Lexical Environment

- `z`가 기록됨.

- 외부 참조 → `foo`

👉 `console.log(x + y + z)` 실행 시, `bar` → `foo` → `global` 순으로 식별자 검색을 이어가며 값을 찾는다.

> 클로저(Closure)와의 연결
>
> 함수가 선언될 때, 자신이 속한 렉시컬 환경에 대한 참조([[Environment]])를 함께 저장한다.
>
> 그래서 함수가 호출될 때마다 이 참조를 바탕으로 외부 변수를 기억할 수 있다.
> → 클로저 = 함수 + 선언 당시의 렉시컬 환경 참조

> TDZ와의 연결
>
> `let`과 `const`는 선언되었지만 초기화되기 전 상태로
> Environment Record에 들어간다.
>
> 이 때문에 접근하면 `ReferenceError`가 발생한다.

---

## 6️⃣ 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

- 실행 컨텍스트는 코드 평가 → 코드 실행 순서로 진행된다.

이 과정에서 변수가 어디에 저장되는지, 함수가 어떻게 외부 스코프를 기억하는지가 결정된다.

변수 참조는 현재 컨텍스트 → Outer Reference → 전역 순으로 이어진다. (스코프 체인)

동작 단계 (전형적인 foo/bar 예제 흐름)

전역 객체 생성 → window / global

전역 코드 평가 → var는 전역 객체, let/const는 선언적 환경에 기록. this 바인딩 결정.

전역 코드 실행 → 값 할당, 함수 호출.

함수 코드 평가 → 매개변수, arguments, 지역 변수 등록. 외부 환경 참조 저장.

함수 코드 실행 → 실제 코드 실행, 식별자 검색 시 스코프 체인 활용.

실행 종료 → 컨텍스트 스택에서 제거(pop).

예제

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}
foo(20); // 42
```

→ `console.log`(a + b + x + y + z) 실행 과정

현재(bar) 환경에서 z 찾음 → O

bar 환경에 a, y, x 없음 → Outer(= foo) 환경으로 이동

foo 환경에서 a, y, x 찾음 → O

필요시 전역 환경까지 이동

왜 중요한가?

스코프 체인의 실제 동작 과정을 이해할 수 있음.

클로저가 동작하는 원리와도 직접 연결됨.

변수 선언 방식(var vs let/const)이 전역 환경에 어떻게 다른 영향을 미치는지 알 수 있음.

---

## 7️⃣ 23.7 실행 컨텍스트와 블록 레벨 스코프.

핵심 요약

ES6 전에는 자바스크립트는 함수 레벨 스코프만 존재.

ES6 이후 let, const는 블록 레벨 스코프를 가지게 됨.

블록이 실행될 때마다 새로운 렉시컬 환경이 만들어졌다가, 블록이 끝나면 원래 환경으로 복귀.

### 예제

```js
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10 (블록 내부 변수)
}

console.log(x); // 1 (전역 변수)
```

→ if 블록이 실행될 때 x=10이 블록 전용 렉시컬 환경에 기록됨.
→ 블록 종료 후에는 다시 전역 환경으로 돌아감.

왜 중요한가?

var를 쓸 때 흔히 생겼던 스코프 꼬임 문제를 해결.

for문에서 let을 사용할 때 매번 독립적인 환경이 만들어지므로 클로저 문제도 해결됨.

TDZ(Temporal Dead Zone)과 연결되어, 초기화 전 접근 시 ReferenceError를 던짐.

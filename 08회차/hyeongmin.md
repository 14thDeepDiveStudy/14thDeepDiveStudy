### 클로저(Closure)의 정의와 핵심 개념

클로저는 자바스크립트의 매우 중요한 개념으로, mdn에서는 다음과 같이 정의함.

> "클로저는 **함수**와 그 함수가 선언된 `렉시컬 환경(Lexical Environment)`과의 조합이다."

이 정의를 쉽게 풀어보면, **함수가 자신이 만들어진 환경(스코프)을 기억해서, 그 환경이 사라진 후에도 그 안의 변수들에 계속 접근할 수 있는 능력**을 의미함.

- **핵심**: 외부 함수의 실행이 끝나고 호출 스택에서 사라져도, 내부 함수는 외부 함수의 스코프에 접근할 수 있다.
- **전제 조건**: 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 나타나는 특성이다.

한편, 이처럼 클로저라는 개념이 필요한 목적은? 객체의 모든 프로퍼티와 메서드가 기본적으로 외부에 공개되는 자바스크립트의 특성이 초래할 수 있는, **의도치 않은 상태변경**이라는 문제점을 방지하는데 있음.

#### 의도치 않은 상태 변경?

경제학에서 말하는 **공유지의 비극**이 예시가 될 수 있음. 마을 사람들이 모두 함께 사용하는 **공동 목초지(공유지)**는 누구나 자유롭게 양을 키울 수 있지만, 아무도 책임지고 관리하지는 않기 때문에 마을 사람들은 각자 자신의 이익을 위해 양을 한 마리라도 더 키우려고 함. 한 명 한 명의 행동은 합리적으로 보이지만, 그 결과 모든 사람이 너도나도 양을 키우면서 목초지는 결국 황폐해지고, 나중에는 아무도 양을 키울 수 없는 비극적인 결말을 맞이하게 됨.

```javascript
// 클로저의 가장 기본적인 형태
function outerFunc() {
  const outerVar = "나는 바깥 변수";

  // innerFunc는 outerFunc의 환경에서 선언되었다.
  function innerFunc() {
    // outerFunc의 실행이 끝나도 outerVar에 접근 가능하다.
    console.log(outerVar);
  }

  return innerFunc;
}

// outerFunc 실행이 끝나고, 그 생명주기는 종료되었다.
const myClosure = outerFunc();

// 하지만 myClosure(innerFunc)는 자신이 태어난 환경을 기억한다.
myClosure(); // 출력: "나는 바깥 변수"
```

---

### 렉시컬 스코프 (Lexical Scope)

클로저를 이해하려면 먼저 **렉시컬 스코프**를 알아야 함. "정적 스코프"라고도 불림.

자바스크립트 엔진은 함수가 **어디서 호출**되었는지가 아니라 **어디에 정의**되었는지에 따라 상위 스코프를 결정한다. 즉, 코드의 문맥에 따라 스코프가 정적으로 결정되는 것이다.

```javascript
const x = 1;

function foo() {
  const x = 10;
  bar(); // bar 함수를 foo 내부에서 '호출'했다.
}

// bar 함수는 전역 스코프에 '정의'되었다.
function bar() {
  // 따라서 bar의 상위 스코프는 전역 스코프다.
  // foo 내부의 x(10)가 아닌 전역 변수 x(1)에 접근한다.
  console.log(x);
}

foo(); // 출력: 1
bar(); // 출력: 1
```

`bar` 함수가 `foo` 함수 내부에서 호출되었지만, `bar`가 정의된 곳은 전역이므로 `bar`의 상위 스코프는 전역 스코프다. 이처럼 함수의 상위 스코프는 코드가 작성된 그 순간, 정적으로 결정된다.

---

### 클로저의 동작 원리: 실행 컨텍스트와 `내부 슬롯`

`클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다` 라고 설명하고 있음. 바로 이 정의속에서 그 함수가 선언된 렉시컬 환경이라는 말이 렉시컬 스코프를 의미하는 것. 내부함수는 외부함수 내에서 정의되고, 내부 함수의 상위스코프는 외부함수로 영구히 결정됨. 나중에 외부 함수의 실행이 끝나고 사라져도, 반환된 내부 함수(클로저)는 자신이 기억하고 있는 출생지 정보(내부 슬롯)를 통해 외부 함수의 변수에 계속 접근할 수 있는 것. 결론적으로, 함수는 태어난 곳(정의된 위치)의 환경을 영원히 기억한다'는 렉시컬 스코프의 대원칙이 바로 클로저라는 개념을 존재하게 하는 근간인 셈. 그렇기 때문에 클로저의 개념을 이해하기 위해서 렉시컬 스코프를 알아야 한다고 책에서 설명하고 있는것.

이하 책의 내용 요약.

클로저는 어떻게 사라진 외부 함수의 변수를 기억할까? 그 비밀은 함수 객체의 내부 슬롯 `내부 슬롯`에 있다.

1.  **함수 객체 생성**: 함수가 정의될 때, 자바스크립트 엔진은 함수 객체를 생성함.
2.  **`내부 슬롯`에 상위 스코프 저장**: 이때, 함수가 정의된 환경, 즉 **상위 스코프의 참조**를 자신의 내부 슬롯 `내부 슬롯`에 저장한다. 이것이 함수가 자신의 "고향"을 기억하는 방식임.
3.  **함수 호출**: 함수가 호출되면 새로운 실행 컨텍스트가 생성됨.
4.  **렉시컬 환경 연결**: 이 실행 컨텍스트의 "외부 렉시컬 환경에 대한 참조에 바로 그 `내부 슬롯` 슬롯에 저장해두었던 상위 스코프의 참조가 할당됨.
5.  **스코프 체인 완성**: 이 연결을 통해 스코프 체인이 완성되고, 함수는 상위 스코프의 변수에 접근할 수 있게 된다.

```javascript
const x = 1; // 전역 스코프

// 1. outer 함수 정의
//    - outer 함수 객체 생성
//    - outer.내부 슬롯에 '전역 렉시컬 환경'의 참조가 저장됨.
function outer() {
  const x = 10; // outer 함수 스코프

  // 2. outer 함수 실행 중 inner 함수 정의
  //    - inner 함수 객체 생성
  //    - inner.내부 슬롯에 현재 실행 중인 'outer 함수의 렉시컬 환경' 참조가 저장됨.
  const inner = function () {
    console.log(x);
  };
  return inner;
}

// 3. outer 함수 호출
//    - outer 실행 컨텍스트 생성 및 스택에 push
//    - inner 함수를 반환하고, outer 실행 컨텍스트는 스택에서 pop (소멸)
const innerFunc = outer();

// 4. innerFunc(클로저) 호출
//    - innerFunc 실행 컨텍스트 생성 및 스택에 push
//    - innerFunc의 "외부 렉시컬 환경 참조"는 inner.내부 슬롯에 저장된
//      'outer 함수의 렉시컬 환경'으로 설정됨.
//    - console.log(x) 실행 시, 현재 스코프에 x가 없으므로 외부 렉시컬 환경(outer 스코프)에서
//      x를 찾아 10을 출력.
innerFunc(); // 10
```

**가장 중요한 점**: `outer` 함수의 실행 컨텍스트는 사라졌지만, `outer` 함수의 **렉시컬 환경**은 `innerFunc`에 의해 여전히 참조되고 있으므로 **가비지 컬렉션의 대상이 되지 않고 메모리에 남아있게 된다.** 이것이 클로저의 핵심 원리다.

---

### 클로저의 활용: 상태 관리와 정보 은닉

클로저는 상태(state)를 안전하게 캡슐화하고 외부로부터의 직접적인 접근을 막는 **정보 은닉**에 매우 유용하게 사용된다.

#### 캡슐화된 카운터 예제

```javascript
const counter = (function () {
  // private 변수: 외부에서 직접 접근 불가능
  let privateCounter = 0;

  // 클로저인 메서드를 포함한 객체를 반환
  return {
    increase: function () {
      return ++privateCounter;
    },
    decrease: function () {
      return --privateCounter;
    },
    getValue: function () {
      return privateCounter;
    },
  };
})();

// privateCounter 변수는 외부에서 보이지 않는다.
// console.log(privateCounter); // Uncaught ReferenceError: privateCounter is not defined

// 오직 counter 객체가 제공하는 메서드를 통해서만 상태를 변경하거나 조회할 수 있다.
console.log(counter.increase()); // 1
console.log(counter.increase()); // 2
console.log(counter.getValue()); // 2
console.log(counter.decrease()); // 1

// 이렇게 상태를 특정 함수들만 접근 가능하도록 제한하여
// 의도치 않은 변경을 막고 프로그램의 안정성을 높인다.
```

이 패턴은 객체의 특정 프로퍼티를 `private`하게 만들어 캡슐화를 흉내 내는 고전적인 방법이다.

---

### 클로저 사용 시 흔히 저지르는 실수 (반복문)

클로저를 활용할 때 `반복문과의 조합`에서 실수가 자주 발생함.

#### 잘못된 예시 (`var` 사용)

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  // 이 함수들은 '정의'만 되고 '실행'되지는 않는다.
  // 각 함수는 전역 변수 i를 참조하는 클로저가 된다.
  funcs[i] = function () {
    console.log("현재 i의 값: " + i);
  };
}

// 루프가 끝난 시점의 i 값은 3이다.
for (var j = 0; j < 3; j++) {
  // 함수를 '실행'하는 시점에는 전역 변수 i가 3이므로,
  // 세 함수 모두 3을 출력한다.
  funcs[j]();
}

// 예상 출력:
// 현재 i의 값: 3
// 현재 i의 값: 3
// 현재 i의 값: 3
```

`var i`는 함수 스코프 변수(여기서는 전역 변수)이므로, `for` 루프가 끝날 때까지 단 하나의 `i` 변수만 존재하고 그 값을 공유함.

#### 해결책 1: 즉시 실행 함수(IIFE)로 새로운 스코프 생성 (ES5)

```javascript
var funcs_solved1 = [];

for (var i = 0; i < 3; i++) {
  (function (id) {
    // 즉시 실행 함수는 호출될 때마다 새로운 스코프를 생성한다.
    // 바깥의 i 값을 id라는 매개변수에 복사하여 가둬둔다.
    funcs_solved1[i] = function () {
      console.log("기억된 id의 값: " + id);
    };
  })(i); // i의 현재 값(0, 1, 2)을 즉시 전달
}

for (var j = 0; j < 3; j++) {
  funcs_solved1[j]();
}

// 예상 출력:
// 기억된 id의 값: 0
// 기억된 id의 값: 1
// 기억된 id의 값: 2
```

#### 해결책 2: `let` 키워드 사용 (ES6+)

`let`과 `const`는 **블록 스코프**를 가짐. `for` 루프에서 `let`을 사용하면, 루프가 반복될 때마다 새로운 렉시컬 환경(스코프)이 생성되고, 각 환경은 그 반복 시점의 `i` 값을 독립적으로 가지게 된다.

```javascript
const funcs_solved2 = [];

// let은 블록 스코프를 가지므로, for 루프가 돌 때마다
// 새로운 스코프가 생성되고 i 변수도 새로 생성된다.
for (let i = 0; i < 3; i++) {
  funcs_solved2[i] = function () {
    console.log("블록 스코프 i의 값: " + i);
  };
}

for (let i = 0; i < 3; i++) {
  funcs_solved2[i]();
}

// 예상 출력:
// 블록 스코프 i의 값: 0
// 블록 스코프 i의 값: 1
// 블록 스코프 i의 값: 2
```

이것이 현재 가장 깔끔하고 권장되는 방법이다.

---

### 정리

- **클로저**는 함수가 자신의 탄생 환경(렉시컬 스코프)을 기억하는 현상이다.
- 이는 함수 객체의 `내부 슬롯` 을 통해 구현된다.
- 클로저 덕분에 소멸된 외부 함수의 변수에 접근하는 것이 가능해진다.
- 이를 이용해 **상태를 캡슐화**하고 **정보를 은닉**하여 코드의 안정성을 높일 수 있다.
- `for` 문과 함께 사용할 때는 `var`의 스코프 문제를 주의해야 하며, **`let`을 사용하는 것이 현대적인 해결책**이다.

클로저는 자바스크립트의 비동기 처리, 콜백 함수, 함수형 프로그래밍 등 다양한 곳에서 핵심적인 역할을 하므로, 이 원리를 잘 이해해두는 것이 중요함.

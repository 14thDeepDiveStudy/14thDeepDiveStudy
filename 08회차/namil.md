## 들어가기에 앞서..

- 저는 저번에 [실행 컨텍스트](https://velog.io/@smang66/23%EC%9E%A5-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8) 때도 그렇고 "클로저"라는 개념을 이미 들어본 적이 있습니다.

---

![지피티 쌤의 함수 연습문제 9/20](https://velog.velcdn.com/images/smang66/post/8ee6d06b-5162-41fb-ab4e-c6ebc6b7c268/image.png)

![Q9. 연습문제에 대한 질문](https://velog.velcdn.com/images/smang66/post/828b35e9-feb3-49da-8611-7c3ffec81c87/image.png)

---

위의 사진은 제가 자바스크립트를 처음 배웠을 때 함수 부분을 학습하기 위해서 chatGPT에게 연습문제를 출제해달라고 부탁한 것 중 일부분입니다.

처음에 기본적인 함수 선언문, 함수 표현식, 화살표 함수 표현식 문제를 풀다가 갑자기 중첩된 함수와 `return`에 정신을 차리지 못한 기억이 나네요.

---

## 클로저의 정의

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.
> -MDN-

이렇게 들었을 때는 감이 안옵니다.. "그 함수가 선언된 **렉시컬 환경**과의 조합이다" 부분이 쉽게 이해되지 않죠.

클로저를 이해하기 위해서는 렉시컬 환경이 뭔지 알고 있어야합니다. 또한 그 외에도 실행 컨텍스트, 렉시컬 환경, 렉시컬 스코프, 함수 객체의 [[Environment]] 내부 슬롯, 스코프 체인까지 정말 알아야할 것이 너~무 많죠

특히 실행 컨텍스트와 렉시컬 환경을 모르고 클로저를 학습한다면, html과 CSS를 모른 상태로 자바스크립트를 학습하는 것과 같은 이치일 것입니다.

그렇기 때문에 클로저를 맛보기 전 간단하게 렉시컬 환경과 렉시컬 스코프, 그리고 스코프 체인에 대해 알아봅시다.

---

## 렉시컬 환경 (Lexical Environment)

- 실행 컨텍스트 안에 들어 있는 데이터 구조.

- “현재 이 스코프 안에서 어떤 식별자가 사용 가능한가?”를 관리한다.

> - 렉시컬 환경의 구성 요소들
>
> 1.  환경 레코드 (Environment Record) → 변수와 함수 선언이 실제로 저장되는 테이블.
>
> 2.  외부 렉시컬 환경 참조 (Outer Lexical Environment Reference) → 바깥(상위) 스코프를 가리키는 포인터.

즉, 렉시컬 환경은 **“내부 테이블 + 바깥 링크”** 두 부분으로 되어 있다

> 예를 들어, 함수가 실행되면 새로운 렉시컬 환경이 만들어지고, 그 함수 안에서 선언한 변수/함수들이 환경 레코드에 기록된다.

++ 함수 내부에서 변수를 찾을 때, 현재 환경 레코드 → 외부 참조 → 그 외부의 외부 참조 → … → 전역까지 탐색한다..

=> 요것이 스코프 체인!

---

## 렉시컬 스코프 (Lexical Scope)

- **"상위 스코프가 어디에 있는데용?"** 을 결정하는 규칙.

  - 자바스크립트는 “렉시컬(정적) 스코프” → 정의된 위치로 상위 스코프가 결정된다.

```js
const x = 1;

function outer() {
  const x = 10;
  function inner() {
    console.log(x);
  }
  return inner;
}
const fn = outer();
fn(); // 10
```

- 평가 단계에서 `const x`와 `outer()`는 실행 컨텍스트의 렉시컬 환경에 등록된다. 또한 함수 실행 컨텍스트를 생성해 `inner()`를 실행하고
  스코프에 저장하고... 23장 실행 컨텍스트에서 배운 "그" 과정들이 진행된다.

- 그렇기 때문에 여기서 `inner()`가 참조하는 `x`는 호출한 곳 (`fn()`이 전역에서 실행됨) 기준이 아니라, 정의된 곳(`outer()` 함수 내부) 기준이다.

> ++ 각 실행 컨텍스트는 내부에 렉시컬 환경을 가지고 있다.
> 그렇기 때문에 `inner`의 상위 스코프는 호출된 전역이 아니라, 정의된 `outer` 함수이다.

---

## 스코프 체인 (Scope Chain)

- 변수 탐색 경로.

위에서 설명했듯이, 코드를 실행할 때 식별자를 찾으면

> 현재 실행 중인 렉시컬 환경의 환경 레코드부터 검색 → 없으면 외부 참조를 따라 상위 스코프 → 최종적으로 전역까지 올라간다!

**즉, 렉시컬 환경이 층층이 연결된 사슬이라고 보면 된다.**

글로만 써져서 머릿속으로 그림이 안그려질텐데, 이벤트 버블링을 알고 있다면 이벤트 버블링의 과정을 떠올리면 된다.

출발점이랑 중단 조건의 차이가 있다는 것(정적 규칙 vs 동적 흐름)만 빼면 둘 다 "부모로 이동"한다는 점은 동일하다.

- 스코프 체인은 상위 렉시컬 환경을 따라 전역까지,

- 이벤트 버블링은 부모의 DOM을 거슬러 올라가 `document`, `window`까지.

---

### 스코프 체인의 코드 예시

```js
const x = "I'm 전역 변수예요";

function outer() {
  // x가 없다!
  function inner() {
    console.log(x); // inner 스코프에서 찾고 없으면 -> outer 스코프에서 찾고 없으면 결국 -> 전역까지 올라감
  }
  inner();
}

outer(); // "I'm 전역 변수예요"
```

---

### 이벤트 버블링의 코드 예시

```html
<div id="parent">
  <button id="child">클릭</button>
</div>

<script>
  // stopPropagation()을 쓰지 않는 한,
  // document.body까지 올라가서 이벤트 핸들러를 실행한다.
  document.getElementById("child").addEventListener("click", () => {
    console.log("버튼에서 이벤트 발생!");
  });

  document.getElementById("parent").addEventListener("click", () => {
    console.log("div(부모) : 호오 여기까지 오다니.. child는 우리 중 최약체다");
  });

  document.body.addEventListener("click", () => {
    console.log("body(할아버지) : 굉장한 투기.. parent마저 꺾고 왔구나");
  });
</script>
```

버튼을 클릭할 경우 가장 안 쪽부터 이벤트가 전파되어

> 버튼에서 이벤트 발생
> div(부모) : 호오 여기까지 오다니.. child는 우리 중 최약체
> body(할아버지) : 굉장한 투기.. parent마저 꺾고 왔구나

순으로 출력된다.

---

### 함수 객체의 내부 슬롯 [[Environment]]

이제 클로저의 핵심이라고 볼 수 있는 "함객내슬" [[Environment]]를 살펴볼것 입니다.

- 정의 순간에 상위 스코프를 챙겨두는 장치. 스코프 체인과 식별자 탐색이 실제로 “어디를 따라 올라가느냐”를 결정하는 좌표라고 보면 된다.

- 함수가 만들어질 때, 자신이 **“어디에서 태어났는가”**를 기록해두며,
  이 기록은 단순한 위치 정보가 아니라, 상위 렉시컬 환경에 대한 참조다.

> **정의 시점에 고정**: 함수가 “만들어지는 순간”의 현재 렉시컬 환경
> (=실행 컨텍스트의 렉시컬 환경)을 가리키는 참조(포인터)를 저장한다.
> 값 스냅샷 X.

> **호출 시점에 사용**: 함수가 호출되면 새 함수 환경이 생기고, 그 바깥(outer)이 바로 함수.[[Environment]]. 이렇게 체인이 연결되어 식별자 탐색 경로가 완성된다.

> **그래서**: “어디서 호출했는가”가 아니라 “어디서 정의되었는가” 가 변수 해석을 결정한다(렉시컬 스코프).

### 언제, 무엇이 저장되나? (정의 시점에서)

함수를 선언/표현하는 그 순간:

```js
const x = 1;

function outer() {
  // ← outer가 만들어질 때
  const x = 10;
  return function inner() {
    // ← inner가 만들어질 때
    console.log(x);
  };
}
```

- `outer.[[Environment]]` ← 전역 렉시컬 환경을 가리킨다.

- `inner.[[Environment]]` ← `outer()` 호출 중이 아니라 `outer()`가 정의된 그 렉시컬 환경(= `outer` 함수 몸체의 환경)을 가리킨다.

포인트: `[[Environment]]`는 “정의 시점의 바깥 환경 참조”를 붙잡는다. 호출 위치와 무관.

> 예외 한 가지!
>
> `new Function('code')`로 만든 함수는 사양상 전역 환경을 `[[Environment]]`로 가진다(주변 스코프 캡처 X).
> 그렇기 때문에 보안/최적화 측면에서도 권장되지 않는다.

---

### 호출 시 무슨 일이 일어나는가? (호출 시점)

- 함수 호출 시:

1. 새 함수 실행 컨텍스트를 생성한다.

2. 새 함수 환경 레코드 생성(매개변수/지역변수 바인딩 자리)

3. 그 `outer` = 함수.`[[Environment]]` 로 연결

4. 식별자 탐색은 “현재 → `outer` → … → 전역” 순으로 진행

따라서 클로저란: 함수.[[Environment]]가 가리키는 외부 환경(들)에 있는 바인딩들을, 함수 바깥 생명주기가 끝난 뒤에도 참조할 수 있는 현상.

---

### 값을 복사해 두는가?”에 대한 오해 풀기

놉. `[[Environment]]`는 값 스냅샷이 아니라 바인딩(칸) 에 대한 참조를 기억한다.

그래서 외부 변수 값이 나중에 변경되면, 클로저에서 보이는 값도 변경된 값이다.

```js
function makeCounter() {
  let v = 0; // 이 바인딩(칸)에 접근하는 클로저
  return () => ++v;
}
const c = makeCounter();
console.log(c()); // 1
console.log(c()); // 2  ← 같은 바인딩을 계속 수정
```

---

### 정의 vs 호출 위치

```js
const x = 1;

function foo() {
  // [[Environment]] = 전역
  const x = 10;
  bar(); // bar는 어디서 정의되었을까?
}

function bar() {
  // [[Environment]] = 전역
  console.log(x);
}

foo(); // 1
```

- `bar`는 전역에서 정의되었으므로 `[[Environment]]`가 전역을 가리킨다.

- `foo` 안에서 호출돼도 `bar`의 스코프 체인은 전역 기준으로 열린다 → 1.

---

### 전형적 클로저

```js
const x = 1;
function outer() {
  const x = 10;
  return function inner() {
    console.log(x);
  };
}
const fn = outer();
fn(); // 10
```

- `inner.[[Environment]]`는`outer`의 렉시컬 환경을 가리킨다.

- `outer`의 실행 컨텍스트는 끝났지만(스택에서 빠짐), 환경 레코드(바인딩 저장소)는 살아 있다. 왜냐면 `inner`가 참조하고 있기 때문에..

---

일종의 Q&A로 정리해보자면

Q: `[[Environment]]`는 값 복사?
A: 바인딩 참조다. 값은 나중에 바뀌면 바뀐 대로 보인다.

Q: 호출 위치가 스코프에 영향?
A: 없다. 정의 위치가 전부다.

Q: `eval`은요?
A: 현재 실행 컨텍스트의 환경에 동적으로 바인딩을 추가/변경할 수 있어 스코프 추론을 흐린다. 사용 지양.

Q: `new Function`은 외부 캡처?
A: 못 한다. 전역만 본다(보안/최적화상 권장 X).

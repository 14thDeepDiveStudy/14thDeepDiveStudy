# JS DeepDive

## 24.클로저

### 클로저의 정의

현재 딥다이브에서 MDN에 나온 클로저의 정의는 다음과 같다고 한다.

> "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다."

그럼 현재(2025년) MDN에서의 클로저의 정의는 무엇일까?
[MDN-클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures)

> "클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합입니다. 즉, 클로저는 내부 함수에서 외부 함수의 범위에 대한 접근을 제공합니다. JavaScript에서 클로저는 함수 생성 시 함수가 생성될 때마다 생성됩니다."

정의만 봐선 아직 클로저가 정확이 어떤 것인지 감이 오질 않는다.
두 정의에서 나오는 키워드는 **함수**와 **외부 함수의 범위**(함수가 선언된 렉시컬 환경) 이라고 할 수 있다.

---

### 렉시컬 스코프와 렉시컬 환경

그럼 복습 겸 **렉시컬 스코프**와 **렉시컬 환경**에 대해 간단히 살펴보면 다음과 같다.

**렉시컬 스코프란?**

> JS엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.
> 이를 렉시컬 스코프(정적 스코프)라 한다.

스코프의 실체는 `실행 컨텍스트`에서 나온 **실행 컨텍스트의 렉시컬 환경**이다.
이 렉시컬 환경은 자신의 "**외부 렉시컬 환경에 대한 참조**"를 통해 상위 렉시컬 환경과 이어진다. **이것이 스코프 체인**

이 두가지를 조합해 렉시컬 스코프를 다시 정의하면 다음과 같다.

> **상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다.**

이 개념을 생각하면서 클로저를 알아가보자.

---

### 함수 객체의 내부 슬롯 `[[Envirment]]`

함수가 정의된 환경과 호출되는 환경은 다를 수 있다.
렉시컬 스코프가 가능하려면 **함수는 자신이 정의된 환경(상위 스코프)를 기억**해야한다.

함수는 자신의 상위 스코프의 참조를 **자신의 내부 슬롯 `[[Envirment]]`에 저장**한다.
즉, 함수 평가 단계에서 함수 객체를 생성할 때 자신의 상위 스코프의 참조를 자신의 내부 슬롯 `[[Envirment]]`에 저장한다.
이 시점은 자신의 상위 스코프가 **실행**되는 시점이고, 실행 중인 실행 컨텍스트가 **상위 함수의 실행 컨텍스트**이기 때문이다.

> 즉, 상위 스코프는
>
> - **함수 객체의 내부 슬롯 `[[Envirment]]`에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조.**
> - 자신이 호출되었을 때 생성할 **"외부 렉시컬 환경에 대한 참조"에 저장될 참조값**.
> - 함수 객체는 내부 슬롯에 저장된 **상위 스코프를 자신이 존재하는 한 기억**한다.

---

### 클로저와 렉시컬 환경

```jsx
const x = "저는 전역변수에유";

function outer() {
  const x = "지금은 지역변수에유";
  const inner = function () {
    console.log(x);
  };

  return inner;
}

const innerFunc = outer();
innerFunc();
```

`innerFunc`함수의 실행 결과는 어떻게 될까.

1. 전역 평가 후 실행 과정 중 `outer`실행
2. 함수 평가 후 실행 과정 중 중첩 함수 `inner`를 반환하고 생명주기 마감(실행 컨텍스트에서 pop)
3. `outer`의 실행 컨텍스트가 제거 되었으므로 지역변수도 생명주기 마감
4. 그럼 `outer`의 실행 결과는 "저는 전역변수에유"인가?

> ❌, 결과는 '**지금은 지역변수에유**'가 출력된다.

지금부터 그 이유를 알아보자.
![](https://velog.velcdn.com/images/wjinss/post/995205a6-9b25-469b-adc5-7ad74f328dd5/image.png)
이전 회차인 `실행 컨텍스트`에서 배웠듯 실행 컨텍스트 스택에서 제거되었어도, 렉시컬 환경은 유지된다고 했다.

예제에선 pop된 `outer`의 렉시컬 환경은 `inner` 의 내부 슬롯 `[[Envirment]]`에 저장된 상태이고, `inner` 는 변수 `innerFunc`에 의해 참조되고 있어 가비지 컬렉터의 대상이 되지 않는다.
`outer`가 반환한 `inner` 를 호출하면 실행 컨텍스트 실행 과정의 외부 렉시컬 환경에 대한 참조 결정 중 내부 슬롯에 저장된 참조값을 할당한다.(`outer`의 스코프)
**상위 스코프를 참조 할 수 있으므로 상위 스코프의 식별자를 참조/변경도 가능하다!**

> 즉, 클로저란
> **외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있는 중첨 함수**

그럼 모든 함수는 상위 스코프를 기억하니깐 모든 함수 === 클로저인가?
답은 ❌ 다.

```jsx
function outer() {
  const x = 1;
  const y = 2;

  function inner() {
    const z = 3;
    console.log(z);
  }

  return inner;
}
const fn = outer();
fn();
```

해당 예제에서 `inner` 함수는 `outer`보다 오래 유지되지만, **상위 스코프의 식별자를 참조하지 않는다.**
그래서 `inner` 함수는 클로저가 아니다.

> **상위 스코프의 식별자를 참조해야 된다.**

```jsx
function outer() {
  const x = 1;

  function inner() {
    console.log(x);
  }
  inner();
}
outer();
```

해당 예제에서 `inner` 함수는 상위 스코프의 식별자를 참조하지만, `outer` 함수 외부로 반환되지 않는다.
즉, `outer` 함수보다 **생명 주기가 짧으며**, `outer` 함수보다 **일찍 소멸**한다.
그래서 `inner` 함수는 클로저가 아니다.

> **외부 함수보다 더 오래 유지되어야 된다.**

각 예제에서 등장하는 `const x = 1`는 상위 스코프에서 클로저가 참조하고 있는 식별자이다.
이처럼 클로저에 의해 참조되는 상위 스코프의 변수를 **자유 변수**(free variable)한다.

> 즉, 클로저란 "**자유 변수에 의해 묶여있는 함수**"라고 할 수 있다.
> ~~"함수가 자유 변수에 의해 닫혀있다(closed)"~~

---

### 클로저의 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

> 즉, **상태를 안전하게 은닉**하고 **특정 함수에게만 상태 변경을 허용**하기 위해 사용한다.

```jsx
let num = 0;

const increase = function () {
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 예제에서 카운트의 상태(`num`)은 전역 변수를 통해 관리되어 누구나 접근 가능하고 변경할 수 있다.
이는 의도치 않게 상태가 변경될 수 있으며, 카운트의 상태가 변경되어 오류가 발생할 수 있다.

이를 해결하기 위해 `increase`함수에서 카운트의 상태를 관리하는 것(지역 변수)이 바람직하다.

```jsx
const increase = function () {
  let num = 0;
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 1
console.log(increase()); // 1
```

카운트의 상태(`num`)는 `increase`함수의 지역변수라서 의도치 않은 상태 변경을 방지했고, `increase`함수만이 카운트의 상태를 변경할 수 있다.

하지만 이렇게 되면 출력값은 언제나 1이 나와 상태가 변경되기 이전의 상태를 유지하지 못한다.

이전 상태를 유지할 수 있도록 클로저를 사용해 변경하면 다음과 같다.

```jsx
const increase = (function () {
  let num = 0;
  return function () {
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 1
console.log(increase()); // 1
```

즉시 실행 함수가 호출되어 반환한 함수가 `increase` 변수에 할당되고, 즉시 실행 함수는 소멸된다.
이때, `increase`는 **상위 스코프를 기억하는 클로저**이며, **자유 변수** `num`을 참조, 변경할 수 있다.
그 결과 `num`이 초기화 되지 않고, 이전 값을 기억해 카운트 상태를 유지할 수 있다.

---

### 캡슐화와 정보 은닉

**캡슐화란?**

- 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 메서드를 하나로 묶는 것

**정보 은닉이란?**

- 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 캡슐화
- 구현의 일부를 외부에 공개되지 않도록 감춰 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성인 결합도를 낮추는 효과가 있다.

JS는 대부분의 객체지향 프로그래밍 언어와 달리 **접근 제한자**(`public`,`private`,`protected`)를 제공하지 않는다.
즉, JS 객체의 모든 프로퍼티와 메서드는 기본적으로 외부의 공개(`public`)된 상태이며 정보 은닉을 완전하게 지원하지 않는다.

인스턴스 메서드를 사용한다면 자유 변수를 통해 `private`를 통해 흉내낼 수 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해 근본적인 해결책이 되지 않는다.

현재는 class에 `private` 필드를 정의할 수 있는 새로운 표준이 생겼으니 그건 class를 배울때 알아보자.

---

### 자주 발생하는 실수

다음은 클로저를 사용할 때 자주 발생하는 실수이다.

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

예시의 결과는 `0,1,2`를 기대했지만 결과값은 `3,3,3`이다.

변수 i는 함수 레벨 스코프를 갖는 var이므로 지역변수가 아닌 전역변수이다. i에 0, 1, 2가 순차적으로 할당되고 `funcs[i] = function () {return i}`가 실행되지만, for문은 증감식이 가장 마지막에 실행되기에 i에 3이 할당되어 값으로 출력된다.

클로저를 사용해 위 예제를 바르게 동작하는 코드로 변경하면 다음과 같다.

```jsx
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = (function (id) {
    return function () {
      return id;
    };
  })(i);
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

즉시 실행 함수를 사용해서 값이 1, 2, 3이 나오게 만들었다. 그런데 가독성이 매우매우 떨어지는 느낌이 든다.
결국 `var`가 문제다.

이걸 `let`으로 변경해보자

```jsx
let funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (let j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

![](https://velog.velcdn.com/images/wjinss/post/c498e11b-178d-4b08-8b60-7cc155e9a3dc/image.png)
~~편-안~~

for 문의 코드 블록이 반복 실행될 때마다 for문 코드 블록의 새로운 독립적인 렉시컬 환경이 생성되어 식별자의 값을 유지한다.

이처럼 `let`, `const`를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 스냅샷 찍는 것 처럼 정의한다. (단, 반복문의 코드 블록 내부에서 함수를 정의할때만 유의미)
반복문 내부에 함수 정의가 없는 채 생성된 렉시컬 환경은 반복 직후, 아무도 참조하지 않기에 가비지 컬렉터의 대상이 된다.

다른 방법으론 고차 함수를 사용하는 방법이 있다.
이 방법은 변수와 반복ㅁ누의 사용을 억제할 수 있기에 오류를 줄이고 가독성을 좋게 만든다.
대표적인 (배열)고차함수인 `forEacg`, `map`, `filter`...

---

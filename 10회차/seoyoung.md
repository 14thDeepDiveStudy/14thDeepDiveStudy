## 1. 정규 표현식

### 정규 표현식이란?

**정규 표현식(regular expression)** = 일정한 패턴을 가진 문자열의 집합을 표현하기 위한 형식 언어.

‘문자열’을 대상으로 패턴 매칭 기능을 제공한다.  
여기서 패턴 매칭은 특정 패턴과 일치하는 문자열을 검색, 추출, 치환할 수 있는 기능을 뜻함.

정규 표현식은 패턴과 플래그로 이루어져 있으며  
패턴(pattern)은 문자열의 일정한 규칙을 표현하기 위해,  
플래그(flag)는 정규 표현식 검색 방식을 설정하기 위해 사용한다.

### 정규 표현식 생성

정규 표현식 역시 객체이며 `RegExp` 클래스에서 상속된 여러 메서드를 사용할 수 있다.  
주 프로퍼티는 패턴에 따른 문자열 `source` 와 플래그 집합인 `flags` 문자열.

이 객체를 생성하기 위해선 두 가지 방법이 사용된다.

1. **정규 표현식 리터럴**

   패턴과 플래그로 구성되며 문자열과 비슷한 형태이다. 가장 많이 쓰이는 객체 생성 방식.  
   패턴 전후로 `/` 기호를 나타내며 옵션이 있다면 해당 플래그를 붙여 준다.

   ```tsx
   /pattern/[flags];
   ```

   ↓ 예시

   ```tsx
   const target = 'Is this all there is?';

   const regexp = /is/i;
   regexp.test(target); // true
   ```

2. RegExp 생성자 함수

   `RegExp` 생성자 함수를 사용하여 객체를 생성하는 방식.  
   인수로 패턴과 플래그(옵션)를 받아 온다.

   ```tsx
   new RegExp(pattern[, flags]);
   new RegExp(/pattern/[flags]);
   new RegExp(/pattern/[, flags]);
   ```

   ↓ 예시

   ```tsx
   const target = 'Is this all there is?';

   const regexp = new RegExp(/is/i);
   regexp.test(target); // true
   ```

### RegExp 메서드

정규 표현식 객체는 `RegExp.prototype` 의 메서드를 상속받아 쓸 수 있다.

1. **RegExp.prototype.exec**

   매칭 결과 상세 내용을 객체로 반환하는 메서드

   ```tsx
   regExp.exec(str);
   ```

   - 반환값 `Array | null`
     - 매칭 결과 있는 경우 → 결과 배열
     - 매칭 결과 없는 경우 → `null`
   - 결과 배열 구성 요소
     - `[0]` : 매칭된 전체 문자열
     - `[1...]` : 캡처된 그룹들
     - `index` : 매칭 시작 인덱스
     - `input` : 원래 문자열
     - `groups` : 네임드 그룹이 있는 경우 객체 반환

2. **RegExp.prototype.test**

   매칭 결과를 불리언으로 반환하는 메서드

   ```tsx
   regExp.test(str);
   ```

   - 반환값 `Boolean`
     - 매칭 결과 있는 경우 → `true`
     - 매칭 결과 없는 경우 → `false`

### 정규 표현식 관련 String 메서드

문자열 전체에 상속되는 `String.prototype` 메서드들 중  
정규 표현식을 인수로 받아 문자열에 적용 가능한 메서드 역시 많이 존재한다.

1. **String.prototype.match**

   ```tsx
   str.match(regExp);
   ```

   - 반환값 `Array`
     - `g` 플래그가 있는 경우 → 매칭 결과 배열 (`exec()` 메서드와 동일)
     - `g` 플래그가 없는 경우 → 매칭된 문자열의 전체 배열

2. **String.prototype.matchAll**

   ```tsx
   str.matchAll(regExp);
   ```

   - `g` 플래그를 필수 기재해야 함
   - 반환값 `Array`
     - 매칭 결과 배열을 이터레이터로 반환
       (스프레드 문법이나 `for..of` 로 순회 가능하다.)

3. **String.prototype.search**

   정규 표현식을 기반으로 매칭되는 첫 글자의 인덱스를 반환하는 메서드

   ```tsx
   str.search(regExp);
   ```

   - 반환값 `Number`
     - 매칭 결과 있을 경우 → 매칭되는 첫 번째 인덱스
     - 매칭 결과 없을 경우 → `-1`

4. **String.prototype.replace**

   정규식 매칭된 부분을 다른 문자로 대체하는 메서드

   ```tsx
   str.replace(regExp, replacement);
   ```

   - 인수
     - `regExp` : 매칭할 정규식
     - `replacement` : 매칭된 문자열을 대신할 문자열(규칙)
       → 그룹이나 함수도 넣을 수 있다.
   - 반환값 `Number`
     - 매칭 결과 있을 경우 → 매칭되는 첫 번째 인덱스
     - 매칭 결과 없을 경우 → `-1`

5. **String.prototype.replaceAll**

   `replace` 랑 같으나 `g` 플래그가 없어도 매칭된 모든 문자열을 바꿔준다.

   ```tsx
   str.replaceAll(regExp, replacement);
   ```

6. **String.prototype.split**

   정규식을 기준으로 문자열을 나누는 메서드

   ```tsx
   str.split(regExp);
   ```

   - 반환값 `Array`

## 2. 문법

### 플래그

정규 표현식의 검색 방식을 설정하기 위해 사용되는 키워드

| 플래그                                                                           | 의미        | 설명                                                           |
| -------------------------------------------------------------------------------- | ----------- | -------------------------------------------------------------- |
| `i`                                                                              | Ignore case | 대소문자 구분 없이 패턴 검색                                   |
| `g`                                                                              | Global      | 문자열 내 패턴과 일치하는 모든 문자열을 전역 검색함            |
| `m`                                                                              | Multi line  | 문자열 행이 바뀌어도 패턴 검색을 계속함                        |
| `^` , `$` 가 문자열의 각 줄의 시작/끝에도 매칭되도록 함 (기본은 문자열 전체 기준 |
| `s`                                                                              | DotAll      | `.` 이 개행 문자(`\n`) 까지도 매칭되게 함 (기본은 줄바꿈 제외) |
| `u`                                                                              | Unicode     | 패턴을 유니코드 코드포인트 단위로 처리.                        |
| 이모지나 서플리먼터리 문자 대응에 필요함                                         |
| `y`                                                                              | Sticky      | lastIndex 위치부터만 검색해서 매칭.                            |
| g랑 비슷하나 중간 건너뛰기 불가 (정확히 연속된 위치 매칭용)                      |

↓ 예시

```tsx
const target = 'Hello hello\nHELLO';

// g : 전역 검색
target.match(/hello/g); // ["hello"]

// i : 대소문자 무시
target.match(/hello/gi); // ["Hello", "hello", "HELLO"]

// m : 여러 줄 대응
target.match(/^HELLO/m); // ["HELLO"]

// s : . 에 줄바꿈 포함
'ab\ncd'.match(/a.b/s); // ["ab\n"]

// u : 유니코드 안전 처리
'👍'.match(/\u{1F44D}/u); // ["👍"]

// y : sticky(lastIndex 프로퍼티 인덱스부터 검색)
const regex = /hello/y;
regex.lastIndex = 6;
target.match(regex); // ["hello"]
```

### 패턴

정규 표현식의 패턴은 `/` 로 열고 닫으며 문자열 따옴표는 생략한다.  
또한 패턴은 특별한 의미를 가지는 메타문자(meta character) 또는 기호로 표현 가능하다.

1. **문자열 검색(Character Class)**

   | 패턴     | 의미                                | 예시                           |
   | -------- | ----------------------------------- | ------------------------------ |
   | `.`      | 임의의 한 문자 (단, 줄바꿈 제외)    | `/./.test("a") → true`         |
   | `\d`     | 숫자 (digit, `[0-9]`)               | `/\d/.test("123") → true`      |
   | `\D`     | 숫자가 아닌 문자 (`[^0-9]`)         | `/\D/.test("abc") → true`      |
   | `\w`     | 알파벳, 숫자, 밑줄 (`[A-Za-z0-9_]`) | `/\w/.test("_hi123") → true`   |
   | `\W`     | `\w`가 아닌 문자                    | `/\W/.test("!") → true`        |
   | `\s`     | 공백 문자 (스페이스, 탭, 줄바꿈 등) | `/\s/.test(" \n\t") → true`    |
   | `\S`     | 공백이 아닌 문자                    | `/\S/.test("a") → true`        |
   | `[abc]`  | a, b, c 중 하나                     | `/[abc]/.test("apple") → true` |
   | `[^abc]` | a, b, c가 아닌 문자                 | `/[^abc]/.test("d") → true`    |

2. **앵커(Anchors)**

   | 패턴 | 의미                                | 예시                                   |
   | ---- | ----------------------------------- | -------------------------------------- |
   | `^`  | 입력의 시작(`[]` 안에선 NOT의 의미) | `/^hi/.test("hi all") → true`          |
   | `$`  | 입력의 끝                           | `/end$/.test("the end") → true`        |
   | `\b` | 단어 경계 (word boundary)           | `/\bcat\b/.test("my cat") → true`      |
   | `\B` | 단어 경계가 아님                    | `/\Bcat\B/.test("concatenate") → true` |

3. **그룹과 범위(Groups & Ranges)**

   | 패턴           | 의미                 | 예시                                             |
   | -------------- | -------------------- | ------------------------------------------------ |
   | `(abc)`        | 그룹 (캡처됨)        | `/(abc)/.exec("123abc456")[0] → "abc"`           |
   | `(?:abc)`      | 그룹 (캡처하지 않음) | `/(?:abc)/.test("abc") → true`                   |
   | `(?<name>abc)` | 네임드 그룹 (ES2018) | `/(?<word>abc)/.exec("abc").groups.word → "abc"` |
   | `[a-z]`        | a부터 z까지 범위     | `/[a-z]/.test("f") → true`                       |
   | `[A-Z0-9]`     | A~Z 또는 0~9         | `/[A-Z0-9]/.test("Z") → true`                    |

4. **수량자(Quantifiers)**

   | 패턴    | 의미              | 예시                                |
   | ------- | ----------------- | ----------------------------------- |
   | `?`     | 0개 또는 1개      | `/a?/.test("a") → true`             |
   | `*`     | 0개 이상          | `/a*/.exec("aaa")[0] → "aaa"`       |
   | `+`     | 1개 이상          | `/a+/.exec("aaa")[0] → "aaa"`       |
   | `{n}`   | 정확히 n번 반복   | `/a{3}/.test("aaa") → true`         |
   | `{n,}`  | 최소 n번 이상     | `/a{2,}/.exec("aaaa")[0] → "aaaa"`  |
   | `{n,m}` | n번 이상 m번 이하 | `/a{2,4}/.exec("aaaa")[0] → "aaaa"` |

5. **앞뒤 조건(Lookaround)**

   | 패턴     | 의미                                    | 예시                                    |
   | -------- | --------------------------------------- | --------------------------------------- |
   | `(?=p)`  | p로 이어지는 경우 (긍정 lookahead)      | `/\d(?=원)/.exec("100원")[0] → "0"`     |
   | `(?!p)`  | p로 이어지지 않는 경우 (부정 lookahead) | `/\d(?!원)/.exec("100달러")[0] → "0"`   |
   | `(?<=p)` | p 앞에 있는 경우 (긍정 lookbehind)      | `/(?<=₩)\d+/.exec("₩300")[0] → "300"`   |
   | `(?<!p)` | p 앞이 아닌 경우 (부정 lookbehind)      | `/(?<!₩)\d+/.exec("USD300")[0] → "300"` |

## 3. 자주 쓰는 정규표현식

### 검사 패턴

1. 특정 단어로 시작하는지 검사

   ```tsx
   /^https?:\/\//
   /^(http|https):\/\//
   ```

   - `^` : 문자열 시작(앵커포인트)
   - `https?` : "http" 뒤에 "s"가 0개 또는 1개
   - `(http|https)` : http 또는 https
   - `:\/\/` : `://` 에서 `/` 에 이스케이프 `\` 처리한 것

2. 특정 단어로 끝나는지 검사

   ```tsx
   /html$/;
   ```

   - `$` : 문자열 끝

3. 특수문자 포함 여부 검사

   ```tsx
   /[*A-Za-z0-9]/gi;
   ```

   - `[A-Za-z0-9]` : 문자열이 해당 범위에 포함되는지 검사(알파벳 대문자, 소문자, 숫자)
   - `gi` : 전역으로, 대소문자 구분 없이 검색

4. 아이디 유효성 검사

   ```tsx
   /^[A-Za-z0-9]{4,10}$/;
   ```

   - `^` : 문자열 시작
   - `[A-Za-z0-9]` : 문자열이 해당 범위에 포함되는지 검사(알파벳 대문자, 소문자, 숫자)
   - `{4, 10}` : 문자열이 해당 길이에 포함되는지 검사(4 이상 10 이하)
   - `$` : 문자열 끝

5. 메일 유효성 검사(간단 ver)

   ```tsx
   /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/;
   ```

   - `[0-9a-zA-Z]` : 문자열이 해당 범위에 포함되는지 검사(알파벳 대문자, 소문자, 숫자)
   - `([-_\.]?[0-9a-zA-Z])*` : `-` 또는 `_` 또는 `.` 이 0~1번 나올 수 있고, 그 뒤 알파벳/숫자
   - `\.` : `.` 를 이스케이프 처리 `\` 한 것
   - `[a-zA-Z]{2,3}` : com, net, kr 등 2~3글자 영문 검사

6. 전화번호 유효성 검사

   ```tsx
   /’\d{3}-\d{3,4}-\d{4}$/;
   ```

   - `\d{3}` : 숫자 3개 (예: 010)
   - `\d{3,4}` : 숫자 3개 또는 4개
   - `\d{4}` : 숫자 4개
   - `-` : 전화번호 구분 하이픈

## 4. 그 외

연습 사이트 추천

- 정규표현식 연습 샌드박스 → https://regexr.com/5mhou
- 정규표현식 퀴즈 → https://regexone.com/

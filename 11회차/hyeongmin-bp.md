
1. 7번째 데이터 타입, 심벌의 등장 야무쌤 첫수업시간때도 나왔었죠, 7가지중의 하나.. 원래는 6개였다는것입니다.!!
원래 자바스크립트에는 문자열, 숫자, 불리언, undefined, null, 객체까지 총 6개의 데이터 타입이 있었습니다. 그러다 ES6에서 7번째 데이터 타입인 **심벌(Symbol)**이 새롭게 도입되었습니다.
심벌의 가장 큰 특징은 변경이 불가능한 원시 값이면서, 다른 어떤 값과도 중복되지 않는 유일무이한 값이라는 점입니다. 바로 이 '유일성' 때문에, 주로 이름 충돌 위험이 없는 유니크한 프로퍼티 키를 만들 때 사용됩니다.
그럼 그 유니크한걸로 뭘할수 있는가? 그 내용은 뒤에서 가겠습니다.

2. 심벌은 어떻게 만들까요?
심벌 값은 다른 원시 타입처럼 리터럴로 만드는 게 아니라, Symbol() 함수를 호출해서 생성합니다.

여기서 new 연산자는 사용하지 않습니다. new를 쓰면 객체가 생성되지만, 심벌은 앞에서 말한 7번째의 데이터 타입이자 원시 값이거든요. 
그래서 new Symbol()을 시도하면 타입 에러가 발생합니다.
Symbol() 함수 안에는 선택적으로 문자열을 넣을 수 있는데, 이건 디버깅을 위한 '설명'일 뿐, 심벌 값 자체에는 아무런 영향을 주지 않습니다. 
다시말해서 문자열이 같더라도 두 심벌은 완전히 다른 값입니다.
보시는 것처럼 false가 출력되죠. 이것이 바로 심벌의 '유일성'을 보여주는 핵심입니다.

3. 전역에서 심벌 공유하기
만약 애플리케이션 전체에서 딱 하나만 존재하는 심벌을 만들고 공유하고 싶다면 어떻게 할까요? 이때는 Symbol.for() 메소드를 사용합니다.
Symbol.for()는 인수로 받은 문자열을 키로 해서, 전역 심벌 레지스트리라는 곳에서 심벌을 검색합니다.
만약 해당 키의 심벌이 이미 있다면, 그 심벌을 반환하고,
없다면, 새로운 심벌을 생성해서 레지스트리에 저장한 후 반환합니다.

이번엔 true가 나왔죠? Symbol.for()를 쓰면 같은 키에 대해 항상 같은 심벌을 얻을 수 있습니다. 반대로 Symbol.keyFor() 메소드를 사용하면, 전역 심벌의 키를 다시 추출할 수도 있습니다.

(슬라이드 5: 심벌의 활용 사례 1 - 상수)

4. 심벌은 언제 사용할까요?
첫 번째 활용 사례는 상수를 정의할 때입니다. 예를 들어 방향을 나타내는 상수를 정의한다고 해봅시다.

JavaScript

// 기존 방식
const Direction_OLD = { UP: 1, DOWN: 2, LEFT: 3, RIGHT: 4 };

// 심벌 활용 방식
const Direction_NEW = {
  UP: Symbol('up'),
  DOWN: Symbol('down'),
  LEFT: Symbol('left'),
  RIGHT: Symbol('right')
};
기존 방식의 숫자 1, 2, 3, 4는 값 자체에 의미가 없고, 다른 값과 중복될 가능성이 있습니다. 하지만 심벌을 사용하면, 그 자체로 유일무이한 값이 보장되기 때문에 훨씬 안전하고 명확한 상수를 만들 수 있습니다. 여기서 Object.freeze()를 함께 사용하면 자바스크립트에서 enum을 흉내 낼 수도 있죠.

(슬라이드 6: 심벌의 활용 사례 2 - 프로퍼티 키와 은닉)

5. 충돌 없는 프로퍼티 키와 은닉 효과
심벌은 객체의 프로퍼티 키로 사용할 수 있습니다.

JavaScript

const obj = {
  [Symbol.for('mySymbol')]: 1
};

console.log(obj[Symbol.for('mySymbol')]); // 1
이렇게 심벌을 키로 사용하면, 다른 어떤 문자열 키나 미래에 추가될 키와도 절대 충돌하지 않는다는 장점이 있습니다.

또 한 가지 재미있는 특징은, 심벌을 키로 갖는 프로퍼티는 for...in 문이나 Object.keys 같은 일반적인 순회 메소드로는 찾을 수 없다는 점입니다. 덕분에 외부에 노출할 필요 없는 프로퍼티를 은닉하는 효과를 얻을 수 있죠. 물론, Object.getOwnPropertySymbols() 메소드를 사용하면 찾아낼 수 있어서 완벽한 은닉은 아닙니다.

(슬라이드 7: 심벌과 표준 빌트인 객체 확장)

6. 안전하게 표준 객체 확장하기
우리가 Array.prototype 같은 표준 빌트인 객체를 직접 확장하는 건 보통 권장되지 않습니다. 왜냐하면, 내가 추가한 메소드 이름이 나중에 자바스크립트 표준으로 추가될 이름과 겹칠 수 있기 때문이죠.

하지만 이때 심벌을 사용하면 문제가 해결됩니다.

JavaScript

Array.prototype[Symbol.for('sum')] = function () {
  return this.reduce((acc, cur) => acc + cur, 0);
};

console.log( [1, 2][Symbol.for('sum')]() ); // 3
이렇게 심벌 키로 메소드를 추가하면, 어떤 이름과도 충돌할 위험 없이 안전하게 표준 빌트인 객체를 확장할 수 있습니다.

(슬라이드 8: Well-known Symbol과 이터레이션 프로토콜)

7. 이터러블의 세계로...
자바스크립트에는 엔진 내부 알고리즘에 사용되는 Well-known Symbol이라는 빌트인 심벌들이 있습니다. Symbol.iterator, Symbol.asyncIterator 등이 여기에 해당되죠.

이 중에서 오늘 우리가 주목할 것은 바로 **Symbol.iterator**입니다.
이것이 바로 발표의 두 번째 주제인 '이터러블'로 넘어가는 다리 역할을 합니다.

이터레이션 프로토콜이란, ES6에서 도입된 데이터 순회 규칙입니다. 이 규칙을 지키는 객체를 이터러बल(Iterable) 이라고 부르죠. 그리고 어떤 객체가 이터러블이 되려면, 바로 Symbol.iterator를 키로 갖는 메소드를 가지고 있어야 합니다.

(슬라이드 9: 이터러블과 이터레이터)

8. 이터러블과 이터레이터
정리해 보겠습니다.

이터러블(Iterable): Symbol.iterator 메소드를 가진 객체입니다. 이 메소드를 호출하면 '이터레이터'를 반환합니다. Array, String, Map, Set 등이 대표적인 빌트인 이터러블입니다.

이터레이터(Iterator): next() 메소드를 가진 객체입니다. next()를 호출할 때마다 { value, done } 형태의 '이터레이터 리절트' 객체를 반환하며 순차적으로 데이터를 탐색합니다.

이 둘의 관계는 '순회 가능한 자료 구조'와 그 구조를 '탐색하는 포인터'라고 생각하면 쉽습니다.

(슬라이드 10: for...of 문과 사용자 정의 이터러블)

9. 이터러블 활용하기: for...of
이터러블의 가장 대표적인 소비자는 바로 for...of 문입니다.

JavaScript

for (const item of [1, 2, 3]) {
  console.log(item); // 1 2 3
}
for...of 문은 내부적으로 이터러블의 Symbol.iterator를 호출해서 이터레이터를 얻고, done이 true가 될 때까지 next() 메소드를 반복 호출하며 value 값을 꺼내오는 방식으로 동작합니다.

이 원리를 이용하면, 일반 객체도 이터러블로 만들 수 있습니다.

(피보나치 수열 예제 코드 보여주기)

JavaScript

const fibonacci = {
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { value: cur, done: cur >= max };
      }
    };
  }
};

for (const num of fibonacci) {
  console.log(num); // 1 2 3 5 8
}
이렇게 Symbol.iterator와 next를 구현해주면, 우리가 만든 객체도 for...of 문으로 멋지게 순회할 수 있게 됩니다.

(슬라이드 11: 지연 평가와 무한 이터러블)

10. 지연 평가(Lazy Evaluation)의 힘
이터러블의 강력한 특징 중 하나는 지연 평가가 가능하다는 점입니다. 데이터가 필요한 시점, 즉 next() 메소드가 호출되는 순간에 비로소 데이터를 생성하는 기법이죠.

이를 이용하면 무한 이터러블도 만들 수 있습니다.

JavaScript

const fibonacciFunc = function () {
  let [pre, cur] = [0, 1];
  return {
    [Symbol.iterator]() { return this; },
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur }; // done 프로퍼티를 생략하여 무한으로 만듦
    }
  };
};

const [f1, f2, f3] = fibonacciFunc(); // 필요한 만큼만 데이터를 생성
console.log(f1, f2, f3); // 1 2 3
모든 데이터를 메모리에 미리 올려두는 배열과 달리, 지연 평가는 불필요한 메모리 낭비를 막고 실행 속도를 높이며, 무한한 데이터 흐름까지 표현할 수 있게 해줍니다.

(슬라이드 12: 마무리)

11. 정리
오늘 우리는 두 가지 핵심 개념을 배웠습니다.

**심벌(Symbol)**은 **'충돌 걱정 없는 유일한 이름표'**를 만들 때 사용하며, 이를 통해 더 안전하고 확장성 있는 코드를 작성할 수 있습니다.

이터레이션 프로토콜은 **'어떤 데이터든 통일된 방식으로 순회'**하기 위한 약속이며, 이터러블은 for...of, 스프레드 문법 등과 함께 데이터 소비자(Consumer)와 공급자(Provider)를 연결하는 강력한 인터페이스 역할을 합니다.
# 11회차 | Symbol, 이터러블

# **33장\_Symbol**

# _"내가 바로 유일무이한 7번째 타입!"_

### 들어가면서,

자바스크립트가 ECMAScript로 표준화되면서 6개의 타입(**_문자열, 숫자, 불리언, undefined, null, 객체 타입_**)이 존재하게 된다.

그런데 ES6에서 7번째 데이터 타입으로 등장한 것이 있는데, 그게 바로 이번 장에서 살펴볼 **Symbol(심벌)** 이다.

**Symbol(심벌)** 은 다른 값과 _중복되지 않는_ **유일무이한 값** 으로, 주로 충돌 위험이 없는 유일한 프로퍼티 키를 만들때 사용한다.

## Symbol(심벌)

그렇다면 변경 불가능한 원시 타입의 값인 Symbol(심벌)은 어떻게 생성할까?

### Symbol(심벌) 생성

**| 심벌 값은 Symbol 함수를 호출하여 생성하며, 생성된 심벌 값은 외부로 노출되지 않기때문에 확인할 수가 없다.**

```js
// 심벌 값 생성
const mySymbol = Symbol();

console.log(mySymbol); // Symbol()
```

Symbol 함수에는 선택적으로 '문자열' 을 인수로 전달할 수 있는데, 전달하는 '문자열'은 심벌 값에 대한 `설명` 으로, 디버깅 용도로만 사용하며 심벌 값 생성에는 영향을 미치지 않는다.

```js
const mySymbol = Symbol("hello");

console.log(mySymbol); // Symbol(hello)
console.log(mySymbol.description); // hello
console.log(mySymbol.toString()); // Symbol(hello)

console.log(typeof mySymbol); // symbol
console.log(typeof mySymbol.toString()); // string
```

### Symbol(심벌)의 메서드

### 1️⃣ Symbol.for

**| 인수로 전달받은 문자열을 '키'로 사용하여 '키'와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 '키'와 일치하는 심벌 값을 검색하는 메서드이다.**

- **(검색 성공)** 새로운 심벌 값을 생성하지 않고, 검색된 심벌 값을 반환한다.
- **(검색 실패)** 새로운 심벌 값을 생성하여 메서드의 인수로 전달된 '키'로 레지스트리에 저장한 다음 생성된 새로운 심벌 값을 반환한다.

Symbol 함수는 호출될 때마다 `유일무이`한 값을 생성하는데, 생성 당시에는 심벌 값 저장소인 레지스트리에서 해당 심벌 값을 검색할 수 있는 '키'가 지정되어 있지 않기 때문에 ~~전역 심벌 레지스트리에 등록 및 관리되지 않는다.~~

하지만, `Symbol.for` 메서드를 사용하면 전역에서 중복되지 않는 `유일무이` 한 심벌 값을 생성하므로 레지스트리를 통해 공유가능한 상태가 되어 관리가 가능해진다.

### 2️⃣ Symbol.keyFor

**| 전역 심벌 레지스트리에 저장된 심벌 값의 '키'를 추출할 수 있는 메서드이다.**

```js
// Symbol.for 메서드를 사용하여 심벌 값 생성 → 관리 ✅
const s1 = Symbol.for("mySymbol");
Symbol.keyFor(s1); // mySymbol

// Symbol 함수를 사용하여 심벌 값 생성 → 관리 ❌
const s2 = Symbol("haha");
Symbol.keyFor(s2); // undefined
```

---

심벌 값은 다음과 같이 다양하게 활용될 수 있는데, 활용되는 경우들을 간단하게 살펴보자.

- `상수`를 정의할 때 심벌 값으로 상수 값을 생성한다.
- 심벌 값으로 `프로퍼티 키` 를 동적으로 생성할 수 있는데, 심벌 값을 프로퍼티 키로 사용하려면 심벌 값에 `대괄호` 를 사용하면 된다. (접근할 때도 `대괄호` 는 써주기!)
- 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 `for...in`, `Object.keys` 등의 메서드로 찾을 수 없으므로 외부에 노출할 필요가 없는 프로퍼티 은닉이 가능하다. <br />
  (_단, ES6에서 도입된 Object.getOwnPropertySymbols 메서드 사용시에는 찾을 수 있다_)

또한, 심벌 값의 몇 가지 특징으로는 다음과 같은 내용이 있다.

- 일반적으로 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하여 확장하는 것은 권장하지 않으며, 읽기 전용으로 사용하는 것을 권장한다.
- 자바스크립트가 기본적으로 제공하는 빌트인 심벌 값이 있으며, `Well-known-Symbol` 이라고 부른다.

<br />

# **34장\_이터러블**

# _"내가 기준이야! 기준!!"_

### 이터러블 프로토콜이란?

**| 순회 가능한 데이터 컬렉션(자료구조)을 만들기 위한 약속한 규칙이다.**

ES6이전에는 각자의 방법으로 데이터 컬렉션을 순회하였지만, ES6에서는 `이터러블` 로 통일시켜 _'for...of문'_, _'스프레드 문법'_, _'배열 디스트럭처링 할당'_ 의 대상으로 사용할 수 있도록 일원화했다.

---

### 이터러블이란?

**| 이터러블 프로토콜을 준수한 객체를 의미한다.**

Symbol.iterator 를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 의미한다.

이터러블은 `for...of문`으로 순회할 수 있고, 스프레드 문법, 디스트럭처링 할당의 대상으로 사용할 수 있다. <br />
반면, Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블이 아닌 것으로 판단되기 때문에 `for...of문` 순회, 스프레드 문법, 디스트럭처링 할당의 대상으로 사용할 수 없다.

### 이터레이터란?

**| 이터러블의 Symbol.iterator 메서드를 호출하면 반환되는 것을 의미한다.**

이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 `next` 메서드를 갖는다.<br />
이 `next` 메서드는 이터러블의 각 요소 순회를 위한 포인터 역할을하는데, 순회 결과를 나타내는 **이터레이터 리절트 객체**를 반환한다.

**이터레이터 리절트 객체** 의 `value` 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내고, `done` 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.

### 빌트인 이터러블

**| 자바스크립트는 이터레이션 프로토콜을 준수한 객체인 빌트인 이터러블을 제공한다.**

| 이터러블   | Symbol.iterator 메서드                                                          |
| ---------- | ------------------------------------------------------------------------------- |
| Array      | Array.prototype[Symbol.iterator]                                                |
| String     | String.prototype[Symbol.iterator]                                               |
| Map        | Map.prototype[Symbol.iterator]                                                  |
| Set        | Set.prototype[Symbol.iterator]                                                  |
| TypedArray | TypedArray.prototype[Symbol.iterator]                                           |
| arguments  | arguments[Symbol.iterator]                                                      |
| DOM 컬렉션 | NodeList.prototype[Symbol.iterator] , HTMLCollection.prototype[Symbol.iterator] |

### for...of 문

**| 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.**

```js
// 형태 - for...in문과 유사함
for (변수선언문 of 이터러블) {...}
```

1. for...of문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회한다.
2. 그리고 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 변수에 할당한다.
3. 이터레이터 리절트 객체의 done 프로퍼티 값이 false이면 순회를 계속하고 true이면 순회를 중단한다.

### 이터러블과 유사 배열 객체

마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.<br />
유사 배열 객체는 length 프로퍼티를 갖기 때문에 for문으로 순회가 가능하고, 배열처럼 인덱스로 프로퍼티 값에 접근도 가능하다.

단, 단어 그대로 '유사'배열 객체이기 때문에 Symbol.iterator 메서드가 없으므로 for...of 문으로의 순회는 할 수 없다.

---

그렇다면 이터레이션 프로토콜이 왜 필요할까?

이터러블은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 볼 수 있다.<br />
만약, 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 그에 맞는 방식을 모두 지원해야하는 불편함을 느끼게 된다. (~~_비효율적이다_~~)

그렇기때문에 다양한 공급자가 기준인 `이터레이션 프로토콜`을 준수하도록 규정하면 데이터 소비자는 `이터레이션 프로토콜`만 지원하도록 구현하면 되므로 무척 효율적이다. (_소비자와 공급자를 연결해주는 인터페이스 역할_)

---

### 사용자 정의 이터러블

이터레이션 프로토콜을 준수하지 않는 일반 객체도 준수하도록 구현을 하면 사용자 정의 이터러블이 될 수 있다.<br />
이를 통해 다양하게 활용을 할 수 있는데, 대표적인 예시로는 다음 두 가지가 있다.

- 피보나치 수열 구현
- 무한 수열 구현

위 두 가지의 공통점이 있는데, 바로. **지연 평가**를 통해 데이터를 생성한다는 것이다.<br />
**지연 평가** 란 데이터가 필요한 시점 이전까지는 데이터를 생성하지 않다가 필요한 시점이 되면 데이터는 생성하는 기법이다.

`지연 평가` 를 사용하면 불필요한 데이터를 미리 생성하지 않고 필요한 순간에 생성하기 때문에 실행 속도가 향상되고, 불필요한 메모리 소비를 하지않아 '무한'도 표현할 수 있다는 장점이 있다.

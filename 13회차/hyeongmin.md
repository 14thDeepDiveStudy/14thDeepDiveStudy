## 38장 브라우저의 렌더링 과정

자바스크립트는 Node.js의 등장으로 서버 사이드 개발도 가능해졌지만, 여전히 가장 많이 사용되는 분야는 웹 브라우저의 클라이언트 사이드다.

클라이언트 사이드 자바스크립트는 브라우저 내에서 HTML, CSS와 함께 실행된다. 따라서 브라우저가 이 텍스트 문서들을 어떻게 해석(파싱)하고 화면에 출력(렌더링)하는지 아는 것이 중요하다.

  * **파싱(Parsing)**
    텍스트 문서를 읽어 문법적 의미를 갖는 최소 단위인 \*\*토큰(Token)\*\*으로 분해하고, 이 토큰들을 기반으로 \*\*파스 트리(Parse Tree)\*\*라는 트리 구조의 자료구조를 생성하는 과정이다.
  * **렌더링(Rendering)**
    HTML, CSS, 자바스크립트 문서를 파싱하여 브라우저 화면에 시각적으로 출력하는 것이다.

### 브라우저의 렌더링 과정 요약

브라우저는 다음 과정을 거쳐 렌더링을 수행한다.

1.  브라우저는 서버에 렌더링에 필요한 리소스(HTML, CSS, JS 등)를 \*\*요청(Request)\*\*하고 \*\*응답(Response)\*\*을 받는다.
2.  브라우저의 **렌더링 엔진**은 응답받은 HTML과 CSS를 파싱하여 \*\*DOM(Document Object Model)\*\*과 \*\*CSSOM(CSS Object Model)\*\*을 생성한다.
3.  DOM과 CSSOM을 결합하여 \*\*렌더 트리(Render Tree)\*\*를 생성한다.
4.  브라우저의 **자바스크립트 엔진**은 자바스크립트를 파싱하여 실행한다.
5.  렌더 트리를 기반으로 요소의 위치와 크기(**레이아웃**)를 계산하고, 화면에 픽셀을 그리는 **페인팅(Painting)** 작업을 수행한다.

### 38.1 요청과 응답

브라우저의 핵심 기능은 서버에 리소스를 요청하고 응답받아 렌더링하는 것이다.

먼저 주소창의 URL로 서버에 `index.html` 같은 기본 문서를 요청한다. 브라우저의 렌더링 엔진이 이 HTML을 파싱하는 도중에 외부 리소스를 로드하는 태그(예: `<link>`, `<img>`, `<script>`)를 만나면, HTML 파싱을 **일시 중단**하고 해당 리소스 파일을 다시 서버로 요청한다.

### 38.3 HTML 파싱과 DOM 생성

서버가 응답한 HTML 문서는 단순 텍스트다. 렌더링 엔진은 이 텍스트를 파싱하여 브라우저가 이해할 수 있는 자료구조인 \*\*DOM(Document Object Model)\*\*으로 변환한다.

파싱은 `바이트 -> 문자 -> 토큰 -> 노드 -> DOM Tree` 순서로 진행된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
    </ul>
  </body>
</html>
```

위 HTML은 파싱되어 `document` 객체를 정점으로 `html`, `body`, `ul`, `li` 노드가 계층적으로 연결된 DOM 트리를 생성한다.

### 38.4 CSS 파싱과 CSSOM 생성

렌더링 엔진은 HTML을 순차적으로 파싱하며 DOM을 생성하다가 `<link>`나 `<style>` 태그를 만나면 DOM 생성을 **일시 중단**한다.

이후 CSS 파일을 요청/로드하거나 태그 내의 CSS를 파싱한다. HTML과 마찬가지로 `바이트 -> 문자 -> 토큰 -> 노드` 과정을 거쳐 \*\*CSSOM(CSS Object Model)\*\*을 생성한다.

CSSOM은 CSS의 상속 관계를 반영하여 생성된다.

```css
/* 예제 38-03 */
body {
  font-size: 18px;
}
ul {
  list-style-type: none;
}
```

위 CSS가 파싱되면, `ul` 노드는 `list-style-type`과 함께 부모 `body`로부터 상속받은 `font-size` 속성도 갖게 된다. CSS 파싱이 완료되면 HTML 파싱을 재개한다.

### 38.5 렌더 트리 생성

렌더링 엔진은 생성된 **DOM**과 **CSSOM**을 결합하여 \*\*렌더 트리(Render Tree)\*\*를 생성한다.

렌더 트리는 **실제로 화면에 렌더링되는 노드만**으로 구성된다. 따라서 다음과 같은 노드들은 렌더 트리에 포함되지 않는다.

  * `meta`, `script` 태그 등 시각적으로 보이지 않는 노드
  * CSS에 의해 `display: none`으로 설정된 노드

### 38.6 자바스크립트 파싱과 실행

HTML 파싱 중 `<script>` 태그를 만나면, 렌더링 엔진은 DOM 생성을 **일시 중단**하고 제어권을 **자바스크립트 엔진**(예: V8)에게 넘긴다.

자바스크립트 엔진은 코드를 파싱(토크나이징 -\> 파싱 -\> **AST(추상적 구문 트리)** 생성)하고, **바이트코드**로 변환하여 실행한다.

JS 실행이 완료되면 다시 렌더링 엔진으로 제어권이 넘어와 HTML 파싱을 재개한다.

### 38.7 리플로우와 리페인트

만약 자바스크립트가 DOM API를 사용해 DOM이나 CSSOM을 변경하면, 변경된 DOM/CSSOM은 다시 렌더 트리로 결합되고 화면을 다시 렌더링한다.

  * **리플로우(Reflow)**: **레이아웃 계산**을 다시 하는 것. 노드 추가/삭제, 요소 크기/위치 변경 등 레이아웃에 영향을 주는 변경 시 발생한다.
  * **리페인트(Repaint)**: 재결합된 렌더 트리를 기반으로 **다시 페인트**하는 것.

레이아웃에 영향이 없는 변경(예: `background-color` 변경)은 리플로우 없이 리페인트만 실행되지만, **리플로우가 발생하면 반드시 리페인트가 동반된다.** 리플로우는 성능에 악영향을 주는 비싼 작업이다.

```javascript
// 리페인트만 유발 (레이아웃 변경 없음)
const $el = document.getElementById('foo');
$el.style.color = 'red'; 

// 리플로우 + 리페인트 유발 (레이아웃 변경 있음)
$el.style.width = '100px'; 
```

### 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

브라우저는 HTML, CSS, JS를 \*\*순차적(직렬적)\*\*으로 파싱하고 실행한다. 이는 `<script>` 태그의 위치에 따라 HTML 파싱이 \*\*블로킹(blocking)\*\*되어 DOM 생성이 지연될 수 있음을 의미한다.

만약 DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하려 하면 에러가 발생할 수 있다.

```html
<html>
  <head>
    <script>
      // 이 시점엔 <body>가 파싱되기 전이라 'apple' 요소를 찾을 수 없다.
      const $apple = document.getElementById('apple');
      // $apple은 null이므로 에러 발생
      $apple.style.color = 'red'; // TypeError: Cannot read property 'style' of null
    </script>
  </head>
  <body>
    <li id="apple">Apple</li>
  </body>
</html>
```

이러한 문제를 피하기 위해 `<body>` 요소의 가장 아래, 즉 닫는 `</body>` 태그 바로 위에 `<script>`를 위치시키는 것이 좋은 아이디어다.

### 38.9 `script` 태그의 `async` / `defer` 어트리뷰트

자바스크립트 파싱에 의한 DOM 생성 중단(블로킹) 문제를 근본적으로 해결하기 위해 HTML5부터 `async`와 `defer` 어트리뷰트가 추가되었다. (외부 JS 파일 로드 시에만 사용 가능)

```html
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```

두 어트리뷰트 모두 HTML 파싱과 외부 JS 파일의 로드가 \*\*비동기적(병렬)\*\*으로 동시에 진행된다. 하지만 **실행 시점**에 차이가 있다.

  * **`async` 어트리뷰트**
      * JS 파일 로드가 완료되는 **즉시** HTML 파싱을 중단하고 JS를 실행한다.
      * 여러 개의 `async` 스크립트가 있을 경우, 로드 완료된 순서대로 실행되므로 **실행 순서가 보장되지 않는다.**
  * **`defer` 어트리뷰트**
      * JS 파일 로드가 완료되어도 즉시 실행하지 않고, **HTML 파싱이 모두 완료된 직후**에 JS를 실행한다.
      * 여러 개의 `defer` 스크립트가 있을 경우, HTML에 명시된 **순서대로 실행이 보장된다.** DOM 생성이 완료된 이후 실행되어야 할 JS에 유용하다.
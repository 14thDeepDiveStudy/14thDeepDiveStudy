# 38-브라우저의 렌더링 과정

JS는 구글의 V8 엔진으로 빌드된 JS 런타임 환경인 **Node.js**가 등장함으로써 웹의 영역에서 벗어나 **_서버 사이드 애플리케이션_** 영역까지 커버할 수 있는 **범용 개발 언어**가 되었다.
그래도 JS의 메인 분야는 웹 브라우저에서 동작하는 **_웹/앱의 클라이언트 사이드_**다.

대부분의 프로그래밍 언어는 *운영체제(OS)*나 *가상 머신(VM)*에서 실행된다.
하지만 웹/앱의 클라이언트 사이드인 JS는 브라우저에서 **HTML**, **CSS**와 함께 실행된다.

> 브라우저 환경을 고려해 더 효율적인 클라이언트 사이드 JS 프로그래밍 가능

이제부터 프론트엔드라면 알아야되는 **HTML**, **CSS**, **JS**가 어떻게 파싱되고 렌더링 되는지 알아보자.

**파싱과 렌더링?**
그 전에 파싱과 렌더링에 대해 간략히 알아본다.
웹개발을 공부하면서 수도없이 많이 들어봤을 단어지만 아직 자세히 모르겠다면? 지금부터 알아가면 된다.

- **파싱 / parsing**
  구문 분석, 해석이라고 하며 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽고 실행하기 위해 문서의 문자열을 **토큰(token)**으로 분해하고, 토큰에 문법적 의미와 구조를 반영해 트리 구조의 자료구조의 **파스 트리(parse tree)**를 생성하는 과정을 말한다.

- **렌더링 / rendering**
  **HTML**, **CSS**, **JS**로 작성된 문서를 파싱해 브라우저에 시각적으로 출력하는 것을 말한다.

- 브라우저의 렌더링 과정

1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 파일 등 렌더링에 필요한 **리소스를 요청**하고 **서버한테 응답**을 받는다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 **HTML, CSS를 파싱해 DOM과 CSSOM을 생성하고 결합해 렌더 트리를 생성**한다.
3. 브라우저의 JS 엔진은 서버로부터 응답된 JS를 파싱해 **AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환해 실행**한다.
   3.1 이때 JS는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있으며 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.

이제 이 렌더링 과정을 하나씩 자세히 살펴본다.

---

## 요청과 응답

> 브라우저의 핵심 기능은 **필요한 리소스를 서버에 요청하고 응답을 받아 브라우저에 시각적으로 렌더링하는 것**이다.

- **필요한 리소스를 서버에 요청?**
  서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다.
  브라우저의 주소창에 URL를 입력하고 엔터 키를 누르면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 해당 주소를 갖는 서버에 요청을 전송한다.

> **DNS(Domain Name System)**
> DNS는 Domain Name System의 약자로, 사람이 읽을 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 시스템이다.

- **응답을 받아 브라우저에 시각적으로 렌더링?**
  주소창에 `https://www.google.com`을 입력하고 엔터 키를 누르면 **루트요청(`/` 스킴 , `host` 호스트)**요청이 해당 서버로 전송된다.
  루트 요청엔 명확한 리소스 요청이 없지만, 일반적으로 서버는 루트 요청에 대해 암묵적으로 `index.html`을 응답하도록 설정되어있다.
  (정적 파일도 가능하다 - URI 뒤에 정적 파일의 경로와 파일 이름을 기술)

> 즉 `https://www.google.com` 는 `https://www.google.com/index.html` 이다

이것이 우리가 루트에 `index.html`를 만들어야 되는 이유이다.

- **index.html만 받는건가?**
  ![](https://velog.velcdn.com/images/wjinss/post/3cfa10af-0aa2-4f58-afff-3390038a58b4/image.png)

개발자 도구의 NetWork 패널을 확인해보면 `index.html` 뿐만 아니라 CSS, JS, 이미지, 폰트 파일도 응답된 것을 볼 수 있다.
이는 별다른 요청을 하지 않아도 브라우저의 렌더링 엔진이 HTML을 파싱하면서 외부 리소스를 로드하는 태그를 만나면 **HTML 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청**하기 때문이다.

- `link`태그: CSS파일 로드
- `img`태그: 이미지파일 로드
- `script`태그: JS 로드
  등..

---

## HTTP 1.1과 HTTP 2.0

HTTP는 HyperText Transfer Protocol의 약자이며, 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다.

### HTTP 1.1

- 커넥션당 하나의 요청과 응답만 처리한다.
- 즉, 여러 개의 요청과 응답을 한번에 전송할 수 없다.
- HTML 문서 내에 포함된 여러 리소스 요청과 응답이 개별적으로 전송된다.

> 리소스 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례해 응답 시간이 증가한다.

### HTTP 2.0

- 커넥션당 여러 개의 요청과 응답이 가능하다. (다중 요청/응답)
- 즉, 여러 리소스의 동시 전송이 가능하다. (멀티플렉싱)
- HTTP 1.1에 비해 페이지 로드 속도가 약 50% 빠르다고 알려진다.

![](https://velog.velcdn.com/images/wjinss/post/9c9b5584-437e-43fd-93a3-4a8c14d4e0b4/image.png)

---

## HTML 파싱과 DOM 생성

요청에 응답된 HTML 문서는 문자열로 이루어진 순수한 텍스트이다.
순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환해 메모리에 저장해야 된다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

브라우저의 렌더링 엔진은 다음과 같은 5가지 과정을 통해 HTML 문서를 파싱해 DOM을 생성한다.
![](https://velog.velcdn.com/images/wjinss/post/5dde79ec-f05f-47a7-9d22-2805cb7276c6/image.png)

1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답 > 서버는 요청된 HTML 파일을 읽어 메모리에 저장 후 메모리에 저장된 **바이트(2진수)를 인터넷을 경유해 응답**

2. 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받음 > 바이트 형태의 HTML 문서는 `meta`태그의 `charset`어트리뷰트에 저장된 **인코딩 방식을 기준으로 문자열 반환**(우리가 읽을 수 있게)

3. 문자열로 반환된 HTML문서를 읽어 문법적 의미를 갖는 코드의 최소 단위인 **토큰(token)** 들로 분해

4. 각 토큰들을 객체로 변환해 **DOM을 구성하는 기본 요소인 노드(node)를 생성** > 내용에 따라 문서, 요소, 어트리뷰트, 텍스트 노트가 생성

5. HTML 문서는 HTML요소들의 집합으로 이루어지며 **중첩 관계를 갖는다.** > HTML 요소의 콘텐츠 영역에 텍스트 뿐만 아니라 다른 HTML 요소도 포함될 수 있으며 이때 요소간 중첩관계에 의해 부자 관계가 형성 > HTML 요소 간의 부자 관계를 반영한 모든 노드들은 **트리 자료구조**를 구성하며 이를 **DOM(Document Object Model)**이라 한다.

> 즉, **DOM은 HTML 문서를 파싱한 결과물**

---

## CSS 파싱과 CSSOM 생성

HTML을 순서대로 파싱하다 CSS를 로드하는 `link`, `style`태그를 만나면 생성을 중단한다고 했다. 그 이후는 어떻게 되는지 알아보자!

앞서 말했듯 CSS 리소스 파일을 만나면 CSS 파일을 서버에 요청해 HTML과 동일한 파싱 과정을 거친다.

바이트 => 문자 => 토큰 => 노드 => **CSSOM**

> **CSSOM(CSS 객체 모델)**
> CSS Object Model은 JS에서 CSS를 조작할 수 있는 API 집합이다.
> HTML 대신 CSS가 대상인 DOM이라고 생각할 수 있으며, 사용자가 CSS 스타일을 동적으로 읽고 수정할 수 있는 방법이다.

이후 파싱을 완료하면 중단된 HTML 부터 다시 파싱을 시작해 **DOM 생성을 재개**한다.

```css
body {
  font-size: 18px;
}

ul {
  list-style-type: none;
}
```

다음과 같은 CSS 파일이 있을때 생성되는 CSSOM은 아래와 같다.

![](https://velog.velcdn.com/images/wjinss/post/34cea7f2-9f61-42d1-8602-0c93ff91bbf6/image.png)

CSSOM은 **CSS의 상속을 반영해 생성** 된다. 위 예제에서 `body` 요소에 적용한 **font-size 프로퍼티**와 `ul` 요소에 적용한 **list-style-type 프로퍼티**는 모두 `li` 요소에 상속된다. 이런 상속 관계가 반영돼 CSSOM이 만들어진다.

---

## 렌더 트리 생성

렌더링 엔진은 생성된 DOM과 CSSOM을 결합해 **렌더트리를 생성**한다.

렌더 트리는 렌더링을 위한 트리 구조의 자료구조다.
따라서 **화면에 렌더링되지 않는 노드**(`meta`, `script`태그등)나 **CSS에 의한 비표시되는 노드**(display:none 등)들은 **포함되지 않는다.**

![](https://velog.velcdn.com/images/wjinss/post/0e714d6d-c634-4897-a5f7-4485a2cb6a1c/image.png)

이렇게 완성된 렌더 트리는 각 HTML 요소의 **레이아웃**(위치와 크기)를 계산하는 데 사용되며, 브라우저 화면에 픽셀을 렌더링하는 **페인팅** 처리에 입력된다.

![](https://velog.velcdn.com/images/wjinss/post/1991ccb7-1e0a-4686-9788-16a5bb4ed65a/image.png)

이런 렌더링 과정은 반복해서 실행될 수 있는데 다음은 그 예시이다.

- JS에 의한 노드 추가 / 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃에 변경을 발생시키는 스타일의 변경
  - width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경

이런 **레이아웃 계산(리플로우)** 과 **페인팅을 다시 실행하는(리페인팅)** 리렌더링은 비용이 많이 들어 성능에 악영향을 주니 빈번하게 발생하지 않도록 주의하자.

---

## JS의 파싱과 실행

렌더링 엔진은 CSS 파싱과 마찬가지로 HTML을 파싱하다 JS 파일을 로드하는 `script`태그를 만나면 **DOM 생성을 일시 중단**한다.

그리고 `script`태그의 **src 어트리뷰트**에 정의된 JS 파일을 서버에 요청해 로드된 파일과 코드를 파싱하기 위해 JS 엔진에게 제어권을 넘긴다.
이후 JS 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 중단된 HTML 부터 다시 파싱을 시작해 **DOM 생성을 재개**한다.

이때 JS 엔진에게 제어권을 넘긴다고 했는데, JS의 파싱과 실행은 JS 엔진이 처리하기 때문이다.
**JS 엔진은 코드를 파싱해 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다**

각 브라우저마다 다양한 JS 엔진이 있지만 **모두 ECMAScript사양을 준수**한다.

**JS 엔진의 파싱 순서?**

**1. 토크나이징(tokenizing)**

- 제어권을 넘겨받은 JS 엔진이 코드를 파싱
- 단순 문자열인 JS 소스 코드를 어휘 분석해 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해

**2. 파싱(parsing)** - 토큰들의 집합을 구문 분석해 **AST 생성**

**3. 바이트코드 생성과 실행**

- AST 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트 코드를 생성 및 실행
- V8 엔진의 경우 터보팬이라 불리는 컴파일러에 의해 최적화된 머신 코드로 컴파일돼 성능 최적화

> **AST**
> 추상 구문 트리(AST, Abstract Syntax Tree)이며, 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다. 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다. 구문이 추상적이라는 의미는 실제 구문에서 나타나는 모든 세세한 정보를 나타내지는 않는다는 것을 의미한다.
> => **불필요한 문법적 세부 정보를 제거하고 코드의 주요 구조만 표현해, 컴파일러나 분석 도구에서 코드의 의미를 파악하고 조작하는 데 사용**

---

## 리플로우와 리페인트

JS 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM, CSSOM이 변경된다.
이때 변경된 DOM, CSSOM은 다시 렌더 트리를 생성하며 렌더링 과정을 다시 수행한다.
이를 **리플로우(reflow)**, **리페인트(repaint)**라고 한다.

![](https://velog.velcdn.com/images/wjinss/post/8f25e872-fa39-42e2-898b-0f09f9d91f1d/image.png)

- **리플로우**

  - 레이아웃의 계산을 다시 하는 것
  - 레이아웃에 영향을 주는 변경이 발생할때 실행(노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이즈 등)

- **리페인트**
  - 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것

> 리플로우와 리페인트는 순차적 동시 실행 ❌
> **레이아웃에 영향이 없는 변경은 리페인트만 실행**

---

## JS 파싱에 의한 HTML 파싱 중단

렌더링 엔진과 JS 엔진은 직렬적으로 파싱을 수행한다.

![](https://velog.velcdn.com/images/wjinss/post/e0ee29d9-6908-45c0-a796-d2b1802ef8db/image.png)

그림과 같이 브라우저는 **동기적으로** HTML, CSS, JS를 파싱하고 실행한다.
이는 `script` 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다.
이처럼 **`script` 태그의 위치는 중요한 의미**를 갖는다.

위 예제에선 `app.js`의 파싱으로 DOM의 생성이 중단된다.
만약 `app.js`에 DOM이나 CSSOM을 변경하는 코드가 있다면 어떨까?
DOM을 변경하려고 하는데 DOM이 생성이 안된 상태라면 에러가 발생한다.

이러한 문제를 회피하기 위해 많은 개발자들이 `body`요소의 가장 아래에 JS를 위치시킨다.
이유는 다음과 같다.

- DOM이 완성되기 전에 JS가 DOM을 조작하면 에러가 발생
- JS 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장이 없어 페이지 로딩 시간 단축

---

## script 태그의 async/defer 어트리뷰트

JS 파싱에 의한 DOM 생성 중단이라는 문제를 해결하기 위해 HTML5부터 `script` 태그에 **async/defer 어트리뷰트**가 추가되었다.
해당 어트리뷰트는 외부 JS파일을 로드하는 경우에만 사용 가능하며 인라인 JS에선 사용할 수 없다.

```html
<script async src="wjinss.js"></script>
<script defer src="wjinss.js"></script>
```

async/defer 어트리뷰트를 사용하면 HTML 파싱과 외부 JS 파일 로드가 **비동기적으로 진행**되지만, **실행 시점엔 차이가 없다.**

### async 어트리뷰트

- HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행
- JS의 파싱, 실행은 JS 파일의 로드가 완료된 직후 진행
- **JS 파일이 실행되면 HTML 파싱이 중단**
- 여러 개의 `script` 태그에 지정 시 로드가 완료된 JS부터 실행 => **순서 보장 ❌**

### defer 어트리뷰트

- HTML 파싱과 외부 JS 파일의 로드가 비동기적으로 동시에 진행
- **DOM이 생성된 후(HTML 파싱 후)** JS의 파싱과 실행이 진행
  - `DOMContentLoaded` 이벤트 발생
- DOM 생성이 완료된 이후 실행될 JS에 적합!

![](https://velog.velcdn.com/images/wjinss/post/0adf4192-b0b7-4f46-a83b-be48860697ec/image.png)

### type="module"

ES6에서 JS의 단점을 보완한 모듈 시스템이며, 필자가 가장 많이 사용하는 방식이다.
그럼 왜 가장 많이 사용하냐? 다음과 같은 장점이 있다.

```html
<script type="module" src="wjinss.js"></script>
```

- 기본적으로 **defer와 동일하게 작동**
  - 모듈 간 `import`된 파일들은 자동으로 async 로드
- **모듈 스코프를 가짐**(전역 스코프 공유 ❌)
- `import` / `export`로 재사용성 증가(개발 효율성, 유지보수성 ↗️)
- 기본적으로 한 번만 실행 (중복 로드 방지)
- 기본적으로 **strict mode 적용**

---

## 요약

1. **HTML 전달 → 파싱 → DOM 생성**
2. **style 태그 / 외부 CSS → CSSOM 생성**
3. **DOM + CSSOM → Render Tree 구성**
   - display:none 요소는 제외됨
4. **Layout (Reflow)**
   - 요소 크기, 위치 계산
   - 뷰포트와 콘텐츠 흐름에 맞게 배치
5. **Paint**
   - 색상, 텍스트, 그림자 등 시각 속성 픽셀 변환
6. **합성 (Compositing)**
   - 여러 레이어 결합 => 최종 화면 출력

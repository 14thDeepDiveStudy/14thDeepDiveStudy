# 1회차 | 비동기 프로그래밍, AJAX, REST-API

### 📚 공부한 핵심 내용 정리

## **42장_비동기 프로그래밍** <br />

- 함수호출 -> 함수코드 평가 -> 함수 실팽 컨텍스트(콜 스택) 생성 <br />
- 함수 실행 종료 -> 실행 컨텍스트 스택에서 팝된 후 제거

- 함수 실행 순서: 스택으로 관리함

- 자바스크립트 엔진은 싱글 스레드임. 즉, 단 `하나`의 실행 컨텍스트를 가짐. => 2개 이상의 함수 동시 실행 불가능 <br />

🔛 실행 컨텍스트 스택
 - 최상위 요소: 실행 중인 실행 컨텍스트
 - 그 외: 대기중인 태스크(task) -> 현재 실행중인 함수가 종료되면 실행 됨

⛔️ 싱글 스레드 방식: 한 번에 하나의 태스크만 실행가능 -> 처리시간이 걸리는 태스트 실행할 경우 작업중단을 의미하는 `블로킹` 발생 <br />

🔀 동기처리: 실행 중인 태스크가 종료될 때까지 다음 실행 태스크는 대기하는 방식
  - 장점: 실행 순서 보장
  - 단점: 태스크 블로킹 현상 발생 <br />

➡️ 비동기처리: 실행 중인 태스크가 종료되지 않은 상태라도 다음 태스트를 곧바로 실행하는 방식
  - 장점: 태스크 블로킹 현상 없음
  - 단점: 실행 순서 미보장
  - 콜백 패턴을 주로 사용함 `() => {}` / 해당 방식은 `콜백 헬` 을 발생시킴 -> 가독성 저하, 에러 예외처리 불가, 여러개의 비동기처리 동시처리 어려움 -> 프로미스에서 부연설명
  - 예시: 타이머 함수(setTimeout, setInterval), HTTP요청, 이벤트 핸들러
  - 이벤트 루프(loop) 와 태스크 큐와 밀접관계임 <br />

🔄 이벤트 루프란? 
   - 자바스크립트의 동시성을 지원함.
   - 브라우저 내장 기능 <br />

> 자바 스크립트 엔진의 구성
1. 콜 스택(call stack)
- 실행 컨텍스트가 추가/제거 되는 곳

2. 힙(heap)
- 객체가 저장되는 메모리 공간
- 실행 컨텍스트는 힙에 저장된 객체를 참조함
- 객체는 크기가 정해져 있지 않아 런타임에 동적으로 할당하여야함 -> 힙도 그게 맞춰 구조화 되어있지 않음

=> 자바스크립트 엔진은 위 두 가지 구성요소를 활용하여 소스코드의 평가와 실행만을 담당함 / 그 외 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당함 <br />

> 브라우저 환경의 구성
1. 태스크 큐(tast queue)
- 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 임시 보관되는 곳

2. 이벤트 루프(event loop)
- 현재 실행 중인 컨텍스트의 유무 및 태스크 큐에 대기중인 함수의 유무를 판단함
- 확인 후 콜 스택이 비어있는데 태스크 큐에 대기중인 함수가 있다면 순차적으로 콜 스택으로 이동시킴 (안내원 같은 느낌)

** 싱글 스레드 방식은 브라우저의 작동 방식이 아닌 **자바스크립트 엔진** 의 작동방식임!!! 
=> 비동기 처리가 진행될 수 있는 이유는 자바스크립트 엔진은 싱글 스레드 방식이지만 구동 환경인 브라우저가 멀티 스레드 방식으로 동작하기 때문임

## **43장_Ajax**
### Ajax
자바스크립트를 사용한 브라우저와 서버간의 비동기 통신 방식 <br />

- 브라우저 -> 서버: 비동기 방식으로 데이터 요청 -> 응답 데이터 수신 후 웹페이지 동적갱신 `<Ajax 프로그래밍 방식>`
- 동작 기반: 브라우저 제공 Web AP인 XMLHttpRequest 객체
- XMLHttpRequest: HTTP 비동기 통신을 위한 `메서드`와 `프로퍼티` 를 제공함

이전 방식과 달라진 점(장점)
- 변경이 필요한 데이터만 서버로부터 전송받음 -> 불필요한 데이터 통신 발생 X
- 변경이 필요하지 않은 부분은 다시 랜더링 하지 않음 -> 화면 깜박거림 현상 발생 X
- 클라리언트-서버 통신: 비동기 방식 -> request 이 후 블로킹 현상 발생 X

> JSON

클라이언트와 서버의 HTTP통신을 위한 `텍스트` 데이터 포맷 / 자바스크립트에 종속되지 않는 독립형 데이터 포맷 -> 가용범위 넓음 <br />

- 표기방식: 객체 리터럴(key, value 구성)과 유사함 / 반드시 `큰따옴표` 로 묶어야함(값은 예외, 문자열은 필수) <br />
- JSON.stringify 메서드: 객체 -> JSON 포맷의 문자열로 변환 => 클라이언트 -> 서버로 객체 전송시 필요한 과정임(객체&배열 JSON 문자열화) `직렬화`<br />
- JSON.parse 메서드: JSON 포맷의 문자열 -> 객체로 변환 / 서버-> 클라이언트에게 전송된 JSON 문자열을 객체로 사용하기 위해 필요한 과정임(JSON 문자열의 객체&배열화) `역직렬화` <br />

> XMLHttpRequest 객체
- 브라우저에서 제공하는 Web API -> 브라우저 환경에서만 정상 실행됨
- HTTP 요청(Request) 전송과 HTTP 응답(Response) 수신을 위한 다양한 메서드 및 프로퍼티 제공함
- 자바스크립트를 사용하여 HTTP요청을 전송하려면 해당 객체를 사용해야함
- 해당 객체는 `생성자 함수` 를 호출하여 생성함 

> HTTP 요청 전송
1. 순서 
- HTTP 요청 초기화: XMLHttpRequest.prototype.open 메서드 이용
- (필요시) 특정 HTTP 요청이 필요할 경우 `헤더값` 설정: XMLHttpRequest.prototype.setRequestHeader 메서드 이용
- HTTP 요청 전송: XMLHttpRequest.prototype.send 메서드 이용

1-1. HTTP 요청 단계별 메서드 <br />
✅ 단계1) **초기화** <br />
XMLHttpRequest.prototype.open 메서드 호출 <br />
``xhr.open(method, url[, async])``
 - method: HTTP 요청 메서드 (클라이언트가 서버에게 하는 요청의 종류와 목적을 알리는 방법) <br />
  -> 주 요청 메서드 5가지 <br />
    ⑴ GET | 리소스 `취득` <br />
    ⑵ POST | 리소스 `생성` <br />
    ⑶ PUT | 리소스 `전체 수정`<br />
    ⑷ PATCH | 리소스 `일부 수정`<br />
    ⑸ DELETE | 리로스 `삭제`<br />

✅ 단계2) **요청 전송** <br />
XMLHttpRequest.prototype.send 메서드 호출 <br />

☑️ 선택단계) **특정 HTTP 요청의 헤더값 설정**
- XMLHttpRequest.prototype.setRequestHeader <br />
- 해당 메서드는 반드시 `open`메서드 호출 이후 호출되어야 함 <br />
- 자주 사용되는 헤더: `Content-type`, `Accept` <br />
  - Content-type 이란? 전송 데이터의 MIME타입의 정보 표현 <br />
    *✋🏻여기서 잠깐! MIME 타입이란, 파일이나 데이터의 종류 및 형식을 나타내는 표준으로 헤더의 `Content-type`에 사용되는 `text`, `application`, `multipart` 와 같은 타입(type) 과 `text/html`, `text/css`, `text/javascript`, `application/json`, `application/x-www-form-rulencode` 와 같은 서브타입(sub-type) 으로 이루어져 있음 <br /> 이러한 MIME 타입은 브라우저가 파일종류를 식별하고 그에 알맞는 방식으로 처리 할 수 있도록 해줌 <br />*
  - Accept 란? 클라이언트가 Reqeust시, Response 받을 데이터의 MIME 타입을 지정할 수 있게 함. 즉, 어떤 타입의 응답을 받기를 원하는지 지정할 수 있음 <br /> -> Accept 헤더 미설정시, `*/*` 로 전송됨 <br />
HTTP 응답처리 <br />
- 서버가 전송한 응답 처리를 위해서는 XMLHttpRequest 객체가 발생시키는 이벤트를 `캐치` 해야함 <br />
- 요청 및 응답 과정을 위해서는 `서버`가 필요하며 이 부분에 대해서 자세히 알고싶다면?  `**REST API**` 로 go! <br />
- 그전에 서버가 반환하는 응답에 대해 조금 더 살펴보자면, HTTP 요청에 대한 현재 상태를 확인해야 함 -> 이유: 응답이 언제 클라이언트에게 도달하는지 알 수가 없기때문에! <br />
현재 상태를 확인하는데 사용되는 이벤트가 XMLHttpRequest가 가지고 있는 이벤트 핸들러 프로퍼티 중 하나인 `readystatechange` 임 <br />
해당 이벤트는 프로퍼티(`readyState`) 가 변경될 때마다 발생함
- 서버의 응답이 완료됐다면 `응답 상태(xhr.status)` 를 확인하여 처리가 정상적으로 이루어졌는지, 에러가 발생하였는지 구분함 <br />
  - Response === 정상 ? 서버의 전송데이터 취득 : 에러 처리 진행 <br />
  - 응답의 현재 상태를 확인하는 `readystatechange` 대신 `load`이벤트 사용도 가능함 -> 둘 의 차이가 있다면 load 이벤트는 HTTP 요청이 `성공`적으로 완료된 경우에 발생한다는 것 => 해당 이벤트를 사용할 경우 추가 확인과정 생략가능 <br />

## **44장_REST API**
- HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식은 규정한 것 => `REST`<br />
- REST를 기반으로 서비스 API 를 구현한 것 => `REST API` <br />

### REST API 구성 <br />
- 크게 `자원(resource)`, `행위(verb)`, `표현(representations)` 로 이루어져 있음 <br />
각 구성요소별 표현하는 방식은 다음과 같음 <br />

| 요소 | 표현 방식 |
| --- | ------ | 
| 자원 | 엔드포인트(URL) | 
| 행위 | HTTP 요청 메서드 |
| 표현 | 페이로드 |

- REST는 자체 표현 구조로 REST API 만으로도 HTTP 요청내용 이해가 가능함 <br />

### REST API 설계 원칙
1️⃣ 엔드포인트(URL)는 리소스를 `표현` 하는데 집중 <br />

리소스를 표현 즉, 식별할 수 있게 하는 것이 중점 -> 엔드포인트 이름은 동사보다는 `명사` 사용을 권장 <br />

2️⃣ 행위(verb)에 대한 정의는 HTTP `요청 메서드` 를 통해서 하기 <br />
- 앞서 Ajax 에서도 살펴봤듯이 클라이언트가 서버에게 하는 요청의 종류와 목적을 알리는 방법인 5가지의 HTTP 요청 메서드를 사용하여 `CRUD` 구현 <br />
    *✋🏻 CRUD 란? Create(생성, POST) / Read(읽기, GET) / Update(갱신, PUT / PATCH) / Delete(삭제, DELETE)* <br />
- 리소스에 대한 행위는 요청 메서드를 통해 표현, URL에 포함시키지 않아야 함 <br />
- HTTP 요청 전송 및 응답 과정을 위해서는 서버가 필요함 -> JSON Server 를 사용하여 가상 REST API 를 구축하여 시뮬레이션을 돌려볼 수 있음 <br />
  - 시뮬레이션 진행시 데이터베이스 필요 -> db.json 파일 생성하여 진행 <br />
  - JSON Server의 데이터베이스 감지 활성화를 위해 db.json 파일명 앞에 `--watch`추가 <br />
  - 이후 각 메서드별 시뮬레이션 진행!! <br />
---

💡 인상 깊었던 점 / 새롭게 알게 된 개념 <br />
❓ 궁금하거나 헷갈리는 부분, 다른 사람 의견 듣고 싶은 부분 <br />
- HTTP 요청 메서드가 GET인 경우 send 메서드에 페이로드로 전달한 인수는 무시되고 요청 몸체는 null로 설정됨